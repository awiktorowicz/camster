{"version":3,"file":"static/js/958.b00b1898.chunk.js","mappings":"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","sources":["camera/CameraUtils.ts","features/contourDetection.ts","features/glareDetection.ts","features/positionDetection.ts","features/featureFactory.ts","services/detectionService.ts","services/validationService.ts","camera/AnimationManger.ts","camera/Camera.tsx"],"sourcesContent":["import cv from '@techstark/opencv-js';\r\nimport { isMobile } from 'react-device-detect';\r\nimport {\r\n  AutoCaptureConfig,\r\n  DetectionFrame,\r\n} from '../context/AutoCaptureConfig';\r\n\r\nexport const getVideoConstraints = () => {\r\n  let videoConstraints = {\r\n    facingMode: { exact: 'user' },\r\n    width: { ideal: 1280 },\r\n    height: { ideal: 720 },\r\n  };\r\n  if (isMobile) {\r\n    videoConstraints = {\r\n      facingMode: { exact: 'environment' },\r\n      width: { ideal: window.innerHeight },\r\n      height: { ideal: window.screen.width },\r\n    };\r\n  }\r\n  return videoConstraints;\r\n};\r\n\r\nexport const setupCanvasSize = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  canvasWrapperRef: any,\r\n  config: AutoCaptureConfig,\r\n  setGlobalData: (config: any) => void,\r\n) => {\r\n  const video = videoRef?.current?.video;\r\n  const canvas = canvasRef.current;\r\n  canvas.width = video.videoWidth;\r\n  canvas.height = video.videoHeight;\r\n  const canvasWrapper = canvasWrapperRef.current;\r\n  canvasWrapper.style.width = `${video.videoWidth}px`;\r\n  canvasWrapper.style.height = `${video.videoHeight}px`;\r\n\r\n  config.guidancePoints = getGuidancePoints(\r\n    config.detectionFrame,\r\n    canvas.width,\r\n    canvas.height,\r\n  );\r\n};\r\n\r\n//TODO: Seperate drawing logic\r\nexport const renderVideoToCanvas = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  config: AutoCaptureConfig,\r\n) => {\r\n  const canv = videoRef?.current?.getCanvas();\r\n  if (canv) {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n    ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\r\n\r\n    const img = cv.imread(canvasRef.current);\r\n\r\n    if (config.guidancePoints) {\r\n      drawGuidanceFrame(img, config.guidancePoints);\r\n    }\r\n\r\n    // // TODO: Will need to be wrapped in a new function. The change is required since multiple imshows are creating a bug and canvases are not updating independently but following the slower refresh..\r\n    // if (config.guidancePoints) {\r\n    //   const context = canvasRef.current.getContext('2d');\r\n    //   context.strokeStyle = 'white';\r\n    //   context.clearRect(0, 0, canv.width, canv.height);\r\n    //   context.lineWidth = config.detectionFrame.thickness;\r\n    //   context.beginPath();\r\n    //   context.rect(\r\n    //     config.guidancePoints[0].x,\r\n    //     config.guidancePoints[0].y,\r\n    //     config.guidancePoints[2].x - config.guidancePoints[0].x,\r\n    //     config.guidancePoints[2].y - config.guidancePoints[0].y,\r\n    //   );\r\n    //   context.stroke();\r\n    // }\r\n\r\n    cv.imshow(canvasRef.current, img);\r\n\r\n    img.delete();\r\n  }\r\n};\r\n\r\n// const drawDebugContour = (input: cv.Mat, points: cv.Point[]) => {\r\n//   let contour = new cv.MatVector();\r\n//   let pointArray = cv.matFromArray(\r\n//     points.length,\r\n//     1,\r\n//     cv.CV_32SC2,\r\n//     points.flatMap((p) => [p.x, p.y]),\r\n//   );\r\n\r\n//   contour.push_back(pointArray);\r\n\r\n//   const isClosed = true;\r\n//   const color = new cv.Scalar(255, 0, 0, 255);\r\n//   const thickness = 2;\r\n\r\n//   cv.polylines(input, contour, isClosed, color, thickness);\r\n\r\n//   pointArray.delete();\r\n//   contour.delete();\r\n// };\r\n\r\n// export const detectDocument = (\r\n//   videoRef: any,\r\n//   canvasRef: any,\r\n//   config: any,\r\n//   updatePointDetected: any,\r\n// ) => {\r\n//   const video = videoRef?.current?.video;\r\n//   // fixes bug https://github.com/opencv/opencv/issues/19922\r\n//   video.height = video.videoHeight;\r\n//   video.width = video.videoWidth;\r\n//   const cap = new cv.VideoCapture(video);\r\n//   const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\r\n//   cap.read(src);\r\n\r\n//   preprocessImage(src);\r\n\r\n//   let contoursVec = new cv.MatVector();\r\n//   let hierarchy = new cv.Mat();\r\n//   cv.findContours(\r\n//     src,\r\n//     contoursVec,\r\n//     hierarchy,\r\n//     cv.RETR_EXTERNAL,\r\n//     cv.CHAIN_APPROX_SIMPLE,\r\n//   );\r\n\r\n//   const minArea = ((video.height / 2) * video.width) / 4;\r\n//   let largestContour = findBiggestContour(contoursVec, minArea);\r\n//   let largestContourPoints = getCornerPoints(largestContour);\r\n\r\n//   updatePointDetected(largestContourPoints);\r\n\r\n//   src.delete();\r\n//   hierarchy.delete();\r\n//   contoursVec.delete();\r\n// };\r\n\r\n// const isQuadrilateral = (contour: cv.Mat | null) => {\r\n//   return contour && contour.rows === 4;\r\n// };\r\n\r\n// const findBiggestContour = (\r\n//   contoursVec: cv.MatVector,\r\n//   minAreaThreshold: number,\r\n// ) => {\r\n//   let maxArea = 1000;\r\n//   let largestContour = null;\r\n\r\n//   for (let i = 0; i < contoursVec.size(); ++i) {\r\n//     let contour = contoursVec.get(i);\r\n//     let area = cv.contourArea(contour);\r\n\r\n//     if (area < minAreaThreshold) {\r\n//       contour.delete();\r\n//       continue;\r\n//     }\r\n\r\n//     let peri = cv.arcLength(contour, true);\r\n//     let approx = new cv.Mat();\r\n//     cv.approxPolyDP(contour, approx, 0.02 * peri, true);\r\n\r\n//     if (area > maxArea && isQuadrilateral(approx)) {\r\n//       if (largestContour) largestContour.delete();\r\n//       largestContour = approx;\r\n//       maxArea = area;\r\n//     } else {\r\n//       approx.delete();\r\n//     }\r\n\r\n//     contour.delete();\r\n//   }\r\n\r\n//   return largestContour;\r\n// };\r\n\r\n// // Note the source is passed by ref\r\n// const preprocessImage = (source: cv.Mat, output: cv.Mat = source) => {\r\n//   // Convert to grayscale\r\n//   cv.cvtColor(source, output, cv.COLOR_RGB2GRAY);\r\n\r\n//   // Apply gaussian blur\r\n//   let kernelSize = Math.max(\r\n//     3,\r\n//     Math.floor(Math.min(source.rows, source.cols) / 100),\r\n//   );\r\n//   cv.GaussianBlur(source, output, new cv.Size(kernelSize, kernelSize), 0, 0);\r\n\r\n//   // Apply canny edge\r\n//   let intensityThresholds = calculateIntensityThresholds(source);\r\n//   cv.Canny(source, output, intensityThresholds[0], intensityThresholds[1]);\r\n\r\n//   // Apply morphology closing\r\n//   let morphKernel = cv.getStructuringElement(\r\n//     cv.MORPH_ELLIPSE,\r\n//     new cv.Size(5, 5),\r\n//   );\r\n//   cv.morphologyEx(source, output, cv.MORPH_CLOSE, morphKernel);\r\n// };\r\n\r\n// // Calculates intensity thresholds required for canny filter\r\n// const calculateIntensityThresholds = (\r\n//   canvas: cv.Mat,\r\n//   lowerScalar: number = 0.66,\r\n//   upperScalar: number = 1.33,\r\n// ) => {\r\n//   let meanIntensity = cv.mean(canvas)[0];\r\n//   let lowerThreshold = lowerScalar * meanIntensity;\r\n//   let upperThreshold = upperScalar * meanIntensity;\r\n\r\n//   return [lowerThreshold, upperThreshold];\r\n// };\r\n\r\nexport const getCornerPoints = (contour: any) => {\r\n  if (!contour) return null;\r\n\r\n  let points: cv.Point[] = [];\r\n  let rect = cv.minAreaRect(contour);\r\n  const center = rect.center;\r\n\r\n  let topLeftPoint;\r\n  let topLeftDistance = 0;\r\n\r\n  let topRightPoint;\r\n  let topRightDistance = 0;\r\n\r\n  let bottomLeftPoint;\r\n  let bottomLeftDistance = 0;\r\n\r\n  let bottomRightPoint;\r\n  let bottomRightDistance = 0;\r\n\r\n  for (let i = 0; i < contour.data32S.length; i += 2) {\r\n    const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\r\n    const distance = Math.hypot(point.x - center.x, point.y - center.y);\r\n    if (point.x < center.x && point.y < center.y) {\r\n      if (distance > topLeftDistance) {\r\n        topLeftPoint = point;\r\n        topLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y < center.y) {\r\n      if (distance > topRightDistance) {\r\n        topRightPoint = point;\r\n        topRightDistance = distance;\r\n      }\r\n    } else if (point.x < center.x && point.y > center.y) {\r\n      if (distance > bottomLeftDistance) {\r\n        bottomLeftPoint = point;\r\n        bottomLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y > center.y) {\r\n      if (distance > bottomRightDistance) {\r\n        bottomRightPoint = point;\r\n        bottomRightDistance = distance;\r\n      }\r\n    }\r\n  }\r\n\r\n  points.push(new cv.Point(topLeftPoint?.x, topLeftPoint?.y));\r\n  points.push(new cv.Point(topRightPoint?.x, topRightPoint?.y));\r\n  points.push(new cv.Point(bottomRightPoint?.x, bottomRightPoint?.y));\r\n  points.push(new cv.Point(bottomLeftPoint?.x, bottomLeftPoint?.y));\r\n  return points;\r\n};\r\n\r\nconst getGuidancePoints = (\r\n  detection: DetectionFrame,\r\n  width: number,\r\n  height: number,\r\n) => {\r\n  const boxWidth = Math.round(width * (detection.width / 100));\r\n  const boxHeight = Math.round(height * (detection.height / 100));\r\n\r\n  const widthFactor = isMobile ? boxWidth / 2 : boxWidth / 4;\r\n\r\n  const heightFactor = boxHeight / 2;\r\n\r\n  const topLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const topRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const bottomLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n  const bottomRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n\r\n  return [topLeft, topRight, bottomRight, bottomLeft];\r\n};\r\n\r\nconst drawGuidanceFrame = (canvas: cv.Mat, points: cv.Point[]) => {\r\n  const white = [255, 255, 255, 255];\r\n  cv.rectangle(canvas, points[0], points[2], white, 2);\r\n};\r\n","import cv from '@techstark/opencv-js';\r\nimport { getCornerPoints } from '../camera/CameraUtils';\r\nimport {\r\n  AutoCaptureConfig,\r\n  ContourDetectionConfig,\r\n} from '../context/AutoCaptureConfig';\r\nimport { IFeature } from './IFeature';\r\n\r\nclass ContourDetection implements IFeature {\r\n  config: ContourDetectionConfig;\r\n  autoCaptureConfig: AutoCaptureConfig;\r\n\r\n  constructor(config: AutoCaptureConfig) {\r\n    this.config = config.features.find(\r\n      (f) => f.factoryName === 'contour',\r\n    ) as ContourDetectionConfig;\r\n    this.autoCaptureConfig = config;\r\n  }\r\n\r\n  validate(imageData: cv.Mat): {\r\n    isValid: boolean;\r\n  } {\r\n    this.config.detectedContour = this.detectDocument(imageData);\r\n    return this.config.detectedContour ? { isValid: true } : { isValid: false };\r\n  }\r\n\r\n  // TODO: Change the canvas type from any\r\n  draw(canvas: any | null): void {\r\n    if (!canvas || !this.config.detectedContour) {\r\n      return;\r\n    }\r\n\r\n    let contour = new cv.MatVector();\r\n    let pointArray = cv.matFromArray(\r\n      this.config.detectedContour.length,\r\n      1,\r\n      cv.CV_32SC2,\r\n      this.config.detectedContour.flatMap((p) => [p.x, p.y]),\r\n    );\r\n\r\n    contour.push_back(pointArray);\r\n\r\n    cv.polylines(\r\n      canvas,\r\n      contour,\r\n      this.config.draw.isClosed,\r\n      this.config.draw.color,\r\n      this.config.draw.thickness,\r\n    );\r\n\r\n    pointArray.delete();\r\n    contour.delete();\r\n  }\r\n\r\n  getFeedback(isValid: boolean): string {\r\n    return isValid\r\n      ? 'Contour detected'\r\n      : 'Position your \"DOCUMENT\" in the frame.';\r\n  }\r\n\r\n  updateConfig(setFunction: any): void {\r\n    // throw new Error('Method not implemented.');\r\n    setFunction({\r\n      ...this.autoCaptureConfig.features.find(\r\n        (f) => f.factoryName === 'contour',\r\n      ),\r\n      ...this.config,\r\n    });\r\n  }\r\n  // ?? Potential idea is to create all required MATs in the constructor and delete them using the release function.\r\n  // release(): void {\r\n  //   // throw new Error('Method not implemented.');\r\n  // }\r\n\r\n  private detectDocument(imageData: cv.Mat): cv.Point[] | null {\r\n    this.preprocessImage(imageData);\r\n\r\n    const detectedContours = this.detectContours(imageData);\r\n\r\n    return detectedContours;\r\n  }\r\n\r\n  private detectContours(imageData: cv.Mat): cv.Point[] | null {\r\n    let contoursVec = new cv.MatVector();\r\n    let hierarchy = new cv.Mat();\r\n    cv.findContours(\r\n      imageData,\r\n      contoursVec,\r\n      hierarchy,\r\n      cv.RETR_EXTERNAL,\r\n      cv.CHAIN_APPROX_SIMPLE,\r\n    );\r\n\r\n    let largestContour = this.findBiggestContour(\r\n      contoursVec,\r\n      this.config.minimumDetectableArea,\r\n    );\r\n    let largestContourPoints = getCornerPoints(largestContour);\r\n\r\n    hierarchy.delete();\r\n    contoursVec.delete();\r\n\r\n    return largestContourPoints;\r\n  }\r\n\r\n  findBiggestContour(contoursVec: cv.MatVector, minAreaThreshold: number) {\r\n    // maxArea is used to store the biggest area and the initial value is used to reduce noise.\r\n    let maxArea = minAreaThreshold;\r\n    let largestContour = null;\r\n\r\n    for (let i = 0; i < contoursVec.size(); ++i) {\r\n      let contour = contoursVec.get(i);\r\n      let area = cv.contourArea(contour);\r\n\r\n      if (area < minAreaThreshold) {\r\n        contour.delete();\r\n        continue;\r\n      }\r\n\r\n      let peri = cv.arcLength(contour, true);\r\n      let approx = new cv.Mat();\r\n      cv.approxPolyDP(contour, approx, 0.02 * peri, true);\r\n\r\n      if (area > maxArea && this.isQuadrilateral(approx)) {\r\n        if (largestContour) largestContour.delete();\r\n        largestContour = approx;\r\n        maxArea = area;\r\n      } else {\r\n        approx.delete();\r\n      }\r\n\r\n      contour.delete();\r\n    }\r\n\r\n    return largestContour;\r\n  }\r\n\r\n  isQuadrilateral(contour: cv.Mat) {\r\n    return contour && contour.rows === 4;\r\n  }\r\n\r\n  private preprocessImage = (source: cv.Mat, output: cv.Mat = source) => {\r\n    // Convert to grayscale\r\n    cv.cvtColor(source, output, cv.COLOR_RGB2GRAY);\r\n\r\n    // Apply gaussian blur\r\n    let kernelSize = Math.max(\r\n      3,\r\n      Math.floor(Math.min(source.rows, source.cols) / 100),\r\n    );\r\n    cv.GaussianBlur(source, output, new cv.Size(kernelSize, kernelSize), 0, 0);\r\n\r\n    // Apply canny edge\r\n    let intensityThresholds = this.calculateIntensityThresholds(source);\r\n    cv.Canny(source, output, intensityThresholds[0], intensityThresholds[1]);\r\n\r\n    // Apply morphology closing\r\n    let morphKernel = cv.getStructuringElement(\r\n      cv.MORPH_ELLIPSE,\r\n      new cv.Size(5, 5),\r\n    );\r\n    cv.morphologyEx(source, output, cv.MORPH_CLOSE, morphKernel);\r\n  };\r\n\r\n  // Calculates intensity thresholds required for canny filter\r\n  private calculateIntensityThresholds = (\r\n    canvas: cv.Mat,\r\n    lowerScalar: number = 0.66,\r\n    upperScalar: number = 1.33,\r\n  ) => {\r\n    let meanIntensity = cv.mean(canvas)[0];\r\n    let lowerThreshold = lowerScalar * meanIntensity;\r\n    let upperThreshold = upperScalar * meanIntensity;\r\n\r\n    return [lowerThreshold, upperThreshold];\r\n  };\r\n}\r\n\r\nexport default ContourDetection;\r\n","import cv from '@techstark/opencv-js';\r\nimport { IFeature } from './IFeature';\r\n\r\nclass GlareDetection implements IFeature {\r\n  updateConfig(): void {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  config: any;\r\n\r\n  private _detectedGlare: cv.MatVector = new cv.MatVector();\r\n\r\n  validate(imageData: cv.Mat): { isValid: boolean; error: string | null } {\r\n    // TODO: brightness threshold should be passed as a parameter\r\n    let glareContours = new cv.MatVector();\r\n    // TODO: Glare Contours are passed by reference, it means I do not need a return in detectGlare\r\n    // TODO: How to clean the memory then???\r\n    this._detectedGlare = this.detectGlare(imageData, glareContours, 240);\r\n\r\n    return this._detectedGlare\r\n      ? { isValid: true, error: null }\r\n      : { isValid: false, error: 'Glare Detected' };\r\n  }\r\n\r\n  draw(canvas: any | null): void {\r\n    if (!canvas || !this._detectedGlare) {\r\n      return;\r\n    }\r\n    for (let i = 0; i < this._detectedGlare.size(); i++) {\r\n      cv.drawContours(\r\n        canvas,\r\n        this._detectedGlare,\r\n        i,\r\n        new cv.Scalar(0, 0, 255, 255),\r\n        2,\r\n      );\r\n    }\r\n  }\r\n\r\n  getFeedback(): string {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  private detectGlare(\r\n    imageData: cv.Mat,\r\n    contoursMatVector: cv.MatVector,\r\n    brightnessThreshold: number,\r\n  ) {\r\n    let gray = new cv.Mat();\r\n    cv.cvtColor(imageData, gray, cv.COLOR_RGB2GRAY);\r\n\r\n    cv.threshold(gray, imageData, brightnessThreshold, 255, cv.THRESH_BINARY);\r\n\r\n    // Find contours of the bright areas\r\n    let glareContours = new cv.MatVector();\r\n    let glareHierarchy = new cv.Mat();\r\n    cv.findContours(\r\n      imageData,\r\n      glareContours,\r\n      glareHierarchy,\r\n      cv.RETR_EXTERNAL,\r\n      cv.CHAIN_APPROX_SIMPLE,\r\n    );\r\n\r\n    for (let i = 0; i < glareContours.size(); i++) {\r\n      let contour = glareContours.get(i);\r\n      let area = cv.contourArea(contour);\r\n\r\n      if (area > 500) {\r\n        let mask = cv.Mat.zeros(imageData.rows, imageData.cols, cv.CV_8UC1);\r\n        cv.drawContours(mask, glareContours, i, new cv.Scalar(255), cv.FILLED);\r\n        let meanIntensity = cv.mean(gray, mask)[0];\r\n\r\n        if (meanIntensity > brightnessThreshold) {\r\n          contoursMatVector.push_back(contour);\r\n        }\r\n        mask.delete();\r\n      }\r\n      contour.delete();\r\n    }\r\n\r\n    glareContours.delete();\r\n    glareHierarchy.delete();\r\n\r\n    return contoursMatVector;\r\n  }\r\n}\r\n\r\nexport default GlareDetection;\r\n","import cv, { Mat } from '@techstark/opencv-js';\r\nimport {\r\n  AutoCaptureConfig,\r\n  ContourDetectionConfig,\r\n} from '../context/AutoCaptureConfig';\r\nimport { IFeature } from './IFeature';\r\n\r\nenum ZoomAction {\r\n  Problem,\r\n  None,\r\n  ZoomIn,\r\n  ZoomOut,\r\n  MoveUp,\r\n  MoveDown,\r\n  MoveLeft,\r\n  MoveRight,\r\n}\r\n\r\ninterface GuidanceBounds {\r\n  minX: number;\r\n  maxX: number;\r\n  minY: number;\r\n  maxY: number;\r\n}\r\n\r\nexport class PositionDetection implements IFeature {\r\n  autoCaptureConfig: AutoCaptureConfig;\r\n  contourDetectionConfig: ContourDetectionConfig;\r\n  config: any; // ????\r\n\r\n  private zoomAction: ZoomAction;\r\n  private guidanceBounds: GuidanceBounds | null;\r\n  private detectedBounds: GuidanceBounds | null;\r\n\r\n  constructor(config: AutoCaptureConfig) {\r\n    this.autoCaptureConfig = config;\r\n    this.contourDetectionConfig = this.autoCaptureConfig.features.find(\r\n      (f) => f.factoryName === 'contour',\r\n    ) as ContourDetectionConfig;\r\n    this.zoomAction = ZoomAction.Problem;\r\n    this.guidanceBounds = this.getBounds(this.autoCaptureConfig.guidancePoints);\r\n    this.detectedBounds = this.getBounds(\r\n      this.contourDetectionConfig.detectedContour,\r\n    );\r\n  }\r\n\r\n  // TODO:: Rewrite this spaghetti\r\n  validate(imageData: Mat): { isValid: boolean } {\r\n    const guidancePoints = this.autoCaptureConfig.guidancePoints;\r\n    const contourDetectionConfig = this.autoCaptureConfig.features.find(\r\n      (f) => f.factoryName === 'contour',\r\n    ) as ContourDetectionConfig;\r\n\r\n    const detectedContour = contourDetectionConfig.detectedContour;\r\n    const margin = this.autoCaptureConfig.validation.sideDetectionMargin;\r\n\r\n    if (!guidancePoints || !detectedContour) return { isValid: false };\r\n\r\n    const distances = this.calculatePointLineDistances(\r\n      detectedContour,\r\n      guidancePoints,\r\n    );\r\n\r\n    let width = guidancePoints[1].x - guidancePoints[0].x;\r\n    if (distances.every((num) => num < 0)) {\r\n      this.zoomAction = ZoomAction.ZoomOut;\r\n      return { isValid: false };\r\n    }\r\n\r\n    if (distances.every((num) => num >= 0)) {\r\n      if (distances.some((distance) => distance / width > margin / 100)) {\r\n        this.zoomAction = ZoomAction.ZoomIn;\r\n        return { isValid: false };\r\n      }\r\n    }\r\n\r\n    if (!this.detectedBounds || !this.guidanceBounds) return { isValid: false };\r\n\r\n    if (this.detectedBounds.minX < this.guidanceBounds.minX) {\r\n      this.zoomAction = ZoomAction.MoveLeft;\r\n      return { isValid: false };\r\n    }\r\n\r\n    if (this.detectedBounds.maxX > this.guidanceBounds.maxX) {\r\n      this.zoomAction = ZoomAction.MoveRight;\r\n      return { isValid: false };\r\n    }\r\n\r\n    // Check up-down\r\n    if (this.detectedBounds.minY < this.guidanceBounds.minY) {\r\n      this.zoomAction = ZoomAction.MoveUp;\r\n      return { isValid: false };\r\n    }\r\n\r\n    if (this.detectedBounds.maxY > this.guidanceBounds.maxY) {\r\n      this.zoomAction = ZoomAction.MoveDown;\r\n      return { isValid: false };\r\n    }\r\n\r\n    this.zoomAction = ZoomAction.None;\r\n    return { isValid: true };\r\n  }\r\n  draw(canvas: any | null): void {\r\n    if (!canvas || !this.autoCaptureConfig.guidancePoints) return;\r\n\r\n    const margin = this.autoCaptureConfig.validation.sideDetectionMargin;\r\n    const width =\r\n      this.autoCaptureConfig.guidancePoints[1].x -\r\n      this.autoCaptureConfig.guidancePoints[0].x;\r\n\r\n    const distanceFromBorder = (width * margin) / 100;\r\n\r\n    const leftLineStartPoint = new cv.Point(\r\n      this.autoCaptureConfig.guidancePoints[0].x + distanceFromBorder,\r\n      this.autoCaptureConfig.guidancePoints[0].y,\r\n    );\r\n\r\n    const leftLineEndPoint = new cv.Point(\r\n      this.autoCaptureConfig.guidancePoints[0].x + distanceFromBorder,\r\n      this.autoCaptureConfig.guidancePoints[3].y,\r\n    );\r\n\r\n    const rightLineStartPoint = new cv.Point(\r\n      this.autoCaptureConfig.guidancePoints[1].x - distanceFromBorder,\r\n      this.autoCaptureConfig.guidancePoints[0].y,\r\n    );\r\n\r\n    const rightLineEndPoint = new cv.Point(\r\n      this.autoCaptureConfig.guidancePoints[1].x - distanceFromBorder,\r\n      this.autoCaptureConfig.guidancePoints[3].y,\r\n    );\r\n\r\n    cv.line(\r\n      canvas,\r\n      leftLineStartPoint,\r\n      leftLineEndPoint,\r\n      new cv.Scalar(0, 255, 0, 255),\r\n      2,\r\n    );\r\n\r\n    cv.line(\r\n      canvas,\r\n      rightLineStartPoint,\r\n      rightLineEndPoint,\r\n      new cv.Scalar(0, 255, 0, 255),\r\n      2,\r\n    );\r\n  }\r\n  getFeedback(isValid: boolean): string {\r\n    switch (this.zoomAction) {\r\n      case ZoomAction.ZoomIn:\r\n        return 'Zoom in on the \"DOCUMENT\"';\r\n      case ZoomAction.ZoomOut:\r\n        return 'Zoom out of the \"DOCUMENT\"';\r\n      case ZoomAction.MoveLeft:\r\n        return 'Move the camera to the left';\r\n      case ZoomAction.MoveRight:\r\n        return 'Move the camera to the right';\r\n      case ZoomAction.MoveUp:\r\n        return 'Move the camera up';\r\n      case ZoomAction.MoveDown:\r\n        return 'Move the camera down';\r\n      case ZoomAction.None:\r\n        return '\"Document\" in the correct position';\r\n      case ZoomAction.Problem:\r\n        return 'Problem with validation.';\r\n    }\r\n  }\r\n\r\n  updateConfig(setFunction: any): void {\r\n    // throw new Error('Method not implemented.');\r\n  }\r\n\r\n  private calculatePointLineDistances = (\r\n    lastDetectedPoints: cv.Point[] | null,\r\n    guidancePoints: cv.Point[] | null,\r\n  ) => {\r\n    if (!lastDetectedPoints || !guidancePoints) return [];\r\n\r\n    let distances = [];\r\n    distances.push(\r\n      this.calculatePointLineDistance(\r\n        lastDetectedPoints[0],\r\n        guidancePoints[0],\r\n        guidancePoints[3],\r\n      ),\r\n    );\r\n    distances.push(\r\n      -this.calculatePointLineDistance(\r\n        lastDetectedPoints[1],\r\n        guidancePoints[1],\r\n        guidancePoints[2],\r\n      ),\r\n    );\r\n    distances.push(\r\n      -this.calculatePointLineDistance(\r\n        lastDetectedPoints[2],\r\n        guidancePoints[1],\r\n        guidancePoints[2],\r\n      ),\r\n    );\r\n    distances.push(\r\n      this.calculatePointLineDistance(\r\n        lastDetectedPoints[3],\r\n        guidancePoints[0],\r\n        guidancePoints[3],\r\n      ),\r\n    );\r\n    return distances;\r\n  };\r\n\r\n  private calculatePointLineDistance = (\r\n    point: cv.Point,\r\n    lineStart: cv.Point,\r\n    lineEnd: cv.Point,\r\n  ) => {\r\n    // Absolute value is not calculated on purpose\r\n    let numerator =\r\n      (lineEnd.y - lineStart.y) * point.x -\r\n      (lineEnd.x - lineStart.x) * point.y +\r\n      lineEnd.x * lineStart.y -\r\n      lineEnd.y * lineStart.x;\r\n    let denominator = Math.sqrt(\r\n      (lineEnd.y - lineStart.y) ** 2 + (lineEnd.x - lineStart.x) ** 2,\r\n    );\r\n\r\n    return numerator / denominator;\r\n  };\r\n\r\n  private getBounds = (points: cv.Point[] | null) => {\r\n    if (!points) return null;\r\n\r\n    const minX = Math.min(...points.map((point) => point.x));\r\n    const maxX = Math.max(...points.map((point) => point.x));\r\n    const minY = Math.min(...points.map((point) => point.y));\r\n    const maxY = Math.max(...points.map((point) => point.y));\r\n\r\n    return { minX, maxX, minY, maxY };\r\n  };\r\n}\r\n","import { AutoCaptureConfig } from '../context/AutoCaptureConfig';\r\nimport ContourDetection from './contourDetection';\r\nimport GlareDetection from './glareDetection';\r\nimport { IFeature } from './IFeature';\r\nimport { PositionDetection } from './positionDetection';\r\n\r\nconst featureList: {\r\n  [key: string]: new (config: any, setGlobalData: any) => IFeature;\r\n} = {\r\n  contour: ContourDetection,\r\n  glare: GlareDetection,\r\n  position: PositionDetection,\r\n};\r\n\r\nexport const createFeature = (\r\n  type: string,\r\n  config: AutoCaptureConfig,\r\n  // !! setGlobalData is not needed anymore\r\n  setGlobalData: any,\r\n): IFeature => {\r\n  const Feature = featureList[type];\r\n  if (!Feature) throw new Error(`Feature ${type} not found`);\r\n  return new Feature(\r\n    // config.features.find((f) => f.factoryName === type),\r\n    config,\r\n    setGlobalData,\r\n  );\r\n};\r\n","import cv from '@techstark/opencv-js';\r\nimport Webcam from 'react-webcam';\r\nimport {\r\n  AutoCaptureConfig,\r\n  DetectionResult,\r\n} from '../context/AutoCaptureConfig';\r\nimport { createFeature } from '../features/featureFactory';\r\n\r\nexport const runDetection = (\r\n  videoRef: React.RefObject<Webcam>,\r\n  // TODO: change type from any\r\n  canvasRef: any,\r\n  autoCaptureConfig: AutoCaptureConfig,\r\n  setGlobalData: any,\r\n) => {\r\n  // TODO: Check how this part of code can be done better\r\n  // Get height and width of the video\r\n  if (!videoRef?.current?.video) {\r\n    return [{ type: 'video', feedback: 'Video not detected.' }];\r\n  }\r\n\r\n  videoRef.current.video.width = videoRef.current.video.videoWidth;\r\n  videoRef.current.video.height = videoRef.current.video.videoHeight;\r\n\r\n  // // Get an image from the camera\r\n  const src = new cv.Mat(\r\n    videoRef.current.video.height,\r\n    videoRef.current.video.width,\r\n    cv.CV_8UC4,\r\n  );\r\n  let cap = new cv.VideoCapture(videoRef.current.video);\r\n  cap.read(src);\r\n\r\n  // Create debug mat\r\n  // TODO: Should be created only in the debug mode. A function (handler) creating/deleting can be created.\r\n\r\n  let drawMat = new cv.Mat(\r\n    videoRef.current.video.height,\r\n    videoRef.current.video.width,\r\n    cv.CV_8UC4,\r\n  );\r\n\r\n  // Clean canvas\r\n  const context = canvasRef.current.getContext('2d');\r\n  context.clearRect(0, 0, 1000, 1000);\r\n\r\n  const featuresToUse = autoCaptureConfig.activeFeatures;\r\n  const detectionResults: DetectionResult[] = [];\r\n\r\n  featuresToUse.forEach((featuresType) => {\r\n    // Clone of the source is created because each feature would edit it since it is passed by ref\r\n    let srcClone = src.clone();\r\n    const feature = createFeature(\r\n      featuresType,\r\n      autoCaptureConfig,\r\n      setGlobalData, // !! Is not needed anymore\r\n    );\r\n\r\n    const result = feature.validate(srcClone);\r\n    srcClone.delete();\r\n\r\n    feature.updateConfig(setGlobalData);\r\n\r\n    // console.log(autoCaptureConfig);\r\n    // debugger;\r\n\r\n    if (autoCaptureConfig.debug) {\r\n      feature.draw(drawMat);\r\n    }\r\n\r\n    detectionResults.push({\r\n      type: featuresType,\r\n      isValid: result.isValid,\r\n      feedback: feature.getFeedback(result.isValid),\r\n    });\r\n  });\r\n\r\n  cv.imshow(canvasRef.current, drawMat);\r\n\r\n  // Clean resources\r\n  src.delete();\r\n  drawMat.delete();\r\n\r\n  autoCaptureConfig.detectionResults.splice(\r\n    0,\r\n    autoCaptureConfig.detectionResults.length,\r\n    ...detectionResults,\r\n  );\r\n\r\n  setGlobalData({ autoCaptureConfig });\r\n};\r\n","import {\r\n  AutoCaptureConfig,\r\n  DetectionResult,\r\n} from '../context/AutoCaptureConfig';\r\n\r\nexport enum FeatureValidationStatus {\r\n  None,\r\n  Some,\r\n  All,\r\n}\r\n\r\nexport class ValidationService {\r\n  validationStatus: FeatureValidationStatus;\r\n  private guidanceService: GuidanceService;\r\n  private timeElapsed: number;\r\n  private timerId: number | null;\r\n  private autoCaptureConfig: AutoCaptureConfig;\r\n  private isPictureTaken: boolean;\r\n\r\n  constructor(\r\n    autoCaptureConfig: AutoCaptureConfig,\r\n    guidanceService: GuidanceService,\r\n  ) {\r\n    this.autoCaptureConfig = autoCaptureConfig;\r\n    this.validationStatus = FeatureValidationStatus.None;\r\n    this.guidanceService = guidanceService;\r\n    this.timerId = null;\r\n    this.timeElapsed = 0;\r\n    this.isPictureTaken = false;\r\n  }\r\n\r\n  validateFeatures = async (detectionResults: DetectionResult[]) => {\r\n    const invalidResults = detectionResults.filter((r) => !r.isValid);\r\n\r\n    // can be done as switch for clarity\r\n    // console.log(invalidResults);\r\n    this.validationStatus =\r\n      invalidResults.length === detectionResults.length\r\n        ? FeatureValidationStatus.None\r\n        : invalidResults.length === 0\r\n        ? FeatureValidationStatus.All\r\n        : FeatureValidationStatus.Some;\r\n\r\n    switch (this.validationStatus) {\r\n      case FeatureValidationStatus.None:\r\n        this.guidanceService.updateGuidanceWithDefaultMessage();\r\n        this.resetTimer();\r\n        break;\r\n      case FeatureValidationStatus.Some:\r\n        // display first failed message\r\n        this.guidanceService.updateGuidanceWithInvalidFeedback(\r\n          invalidResults[0].feedback,\r\n        );\r\n        this.resetTimer();\r\n        break;\r\n      case FeatureValidationStatus.All:\r\n        // !! This case just for debuging\r\n        if (this.isPictureTaken) {\r\n          await new Promise((r) => setTimeout(r, 1500));\r\n          this.isPictureTaken = false;\r\n        }\r\n        // display hold steady message\r\n        this.guidanceService.updateGuidanceWithHoldSteadyMessage();\r\n        // start position validation\r\n        this.validatePositionContinously(\r\n          () => {\r\n            this.guidanceService.updateGuidanceWithSuccessMessage();\r\n            this.isPictureTaken = true;\r\n          },\r\n          () => this.guidanceService.updateGuidanceWithResetMessage(),\r\n        );\r\n        break;\r\n    }\r\n  };\r\n\r\n  private validatePositionContinously = (\r\n    onSucess: () => void,\r\n    onRestart: () => void,\r\n  ) => {\r\n    // Poiston validation functionality\r\n    if (!this.timerId) {\r\n      this.timerId = window.setInterval(() => {\r\n        // if (\r\n        //   validatePosition(this.autoCaptureConfig) &&\r\n        //   this.validationStatus === FeatureValidationStatus.All\r\n        // )\r\n        if (this.validationStatus === FeatureValidationStatus.All) {\r\n          this.timeElapsed += 100;\r\n          console.log(this.timeElapsed);\r\n          if (\r\n            this.timeElapsed >= this.autoCaptureConfig.validation.holdingTime\r\n          ) {\r\n            this.resetTimer();\r\n            onSucess();\r\n          }\r\n        } else {\r\n          this.resetTimer();\r\n          onRestart();\r\n        }\r\n      }, 100);\r\n    }\r\n  };\r\n\r\n  private resetTimer = () => {\r\n    if (this.timerId) {\r\n      clearInterval(this.timerId);\r\n      this.timerId = null;\r\n    }\r\n    this.timeElapsed = 0;\r\n  };\r\n\r\n  // private validatePosition = () => {\r\n  //   // return Math.floor(Math.random() * (2 - 0 + 1)) + 0;\r\n  //   return 1;\r\n  // };\r\n}\r\n\r\nexport class GuidanceService {\r\n  readonly defaultMessage: string;\r\n  readonly holdSteadyMessage: string;\r\n\r\n  // TODO: change from any\r\n  guideRef: any;\r\n\r\n  // TODO: constructor will be needed to pass references to the document type\r\n  constructor(guideRef: React.MutableRefObject<HTMLDivElement | null>) {\r\n    this.guideRef = guideRef;\r\n    this.defaultMessage = 'Position your \"DOCUMENT\" in the frame';\r\n    this.holdSteadyMessage = 'Hold steady to take a photo';\r\n  }\r\n\r\n  updateGuidance = (message: string | null) => {\r\n    // updates the guidance functionality\r\n    this.guideRef.current.innerText = message;\r\n  };\r\n\r\n  updateGuidanceWithDefaultMessage = () => {\r\n    this.updateGuidance(this.defaultMessage);\r\n  };\r\n\r\n  updateGuidanceWithInvalidFeedback = (message: string | null) => {\r\n    this.updateGuidance(message);\r\n  };\r\n\r\n  updateGuidanceWithHoldSteadyMessage = () => {\r\n    this.updateGuidance(this.holdSteadyMessage);\r\n  };\r\n\r\n  updateGuidanceWithSuccessMessage = () => {\r\n    this.updateGuidance('Success, photo taken.');\r\n  };\r\n\r\n  updateGuidanceWithResetMessage = () => {\r\n    this.updateGuidance('Process of taking a picture got interrupted.');\r\n  };\r\n}\r\n","class UniqueNameSet extends Set {\r\n  constructor(values: any) {\r\n    super(values);\r\n\r\n    const names: any = [];\r\n    for (let value of this) {\r\n      if (names.includes(value.name)) {\r\n        this.delete(value);\r\n      } else {\r\n        names.push(value.name);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass AnimationManager {\r\n  private tasks: any = new UniqueNameSet([]);\r\n  private fps: number = 60; // Target FPS\r\n  private lastFrameTime: number = performance.now();\r\n  private animationId: number | null = null; // Store the animation frame ID\r\n\r\n  private run = (currentTime: number) => {\r\n    const deltaTime = currentTime - this.lastFrameTime;\r\n\r\n    // Ensure the tasks only run if enough time has passed to meet the target FPS\r\n    if (deltaTime > 1000 / this.fps) {\r\n      this.tasks.forEach((task: any) => {\r\n        const taskDeltaTime = currentTime - task.lastFrameTime;\r\n        if (taskDeltaTime > 1000 / task.fps) {\r\n          task.task(currentTime);\r\n          task.lastFrameTime = currentTime;\r\n        }\r\n      });\r\n      this.lastFrameTime = currentTime;\r\n    }\r\n\r\n    this.animationId = requestAnimationFrame(this.run);\r\n  };\r\n\r\n  public registerTask(task: FrameRequestCallback, fps: number) {\r\n    this.tasks.add({ task, fps, name: task.toString(), lastFrameTime: 0 });\r\n    if (this.tasks.size === 1) {\r\n      this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\r\n    }\r\n  }\r\n\r\n  public unregisterTask(task: FrameRequestCallback) {\r\n    this.tasks.delete(task);\r\n    if (this.tasks.size === 0 && this.animationId !== null) {\r\n      cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\r\n      this.animationId = null; // Reset the ID\r\n    }\r\n  }\r\n}\r\n\r\nexport const animationManager = new AnimationManager();\r\n","import React, { useRef } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { useGlobalContext } from '../context/GlobalContext';\r\nimport { runDetection } from '../services/detectionService';\r\nimport {\r\n  GuidanceService,\r\n  ValidationService,\r\n} from '../services/validationService';\r\nimport { animationManager } from './AnimationManger';\r\nimport {\r\n  getVideoConstraints,\r\n  renderVideoToCanvas,\r\n  setupCanvasSize,\r\n} from './CameraUtils';\r\n\r\n// TODO: Camera does not need config param, this can be accessed from the global Data\r\nconst Camera = (config: any) => {\r\n  const [globalData, setGlobalData] = useGlobalContext();\r\n\r\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const canvasWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const videoRef = React.useRef<Webcam>(null);\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const canvasDebugRef = useRef<HTMLCanvasElement | null>(null);\r\n  const guideRef = React.useRef<HTMLDivElement | null>(null);\r\n  const screenReaderRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n  const videoConstraints = getVideoConstraints();\r\n\r\n  const initialiseCanvas = () => {\r\n    setupCanvasSize(\r\n      videoRef,\r\n      canvasRef,\r\n      canvasWrapperRef,\r\n      globalData.autoCapture,\r\n      setGlobalData,\r\n    );\r\n  };\r\n\r\n  const renderVideo = () => {\r\n    renderVideoToCanvas(videoRef, canvasRef, globalData.autoCapture);\r\n  };\r\n\r\n  const guidanceSercice = new GuidanceService(guideRef);\r\n  const validationService = new ValidationService(\r\n    globalData.autoCapture,\r\n    guidanceSercice,\r\n  );\r\n\r\n  const runValidations = () => {\r\n    validationService.validateFeatures(globalData.autoCapture.detectionResults);\r\n  };\r\n\r\n  // const runDetection = () => {\r\n  //   detectDocument(videoRef, canvasRef, config, updatePointDetected);\r\n  // };\r\n\r\n  // const runCapturing = () => {\r\n  //   captureDocument(\r\n  //     globalData.autoCapture.guidancePoints,\r\n  //     globalData.autoCapture.lastDetectedPoints,\r\n  //     globalData.autoCapture.isAreaValid,\r\n  //     globalData.autoCapture.isPositionValid,\r\n  //     updateIsValidArea,\r\n  //     updateIsValidPosition,\r\n  //     guideRef,\r\n  //     config.capturingType,\r\n  //     config.capturingMargin,\r\n  //   );\r\n  // };\r\n\r\n  // const updatePointDetected = (points: any) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.lastDetectedPoints = points;\r\n  //   setGlobalData(globalDataUpdate);\r\n  // };\r\n\r\n  // const updateGuidancePoints = (points: any) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.guidancePoints = points;\r\n  //   setGlobalData(globalDataUpdate);\r\n  // };\r\n\r\n  // const updateIsValidArea = (isValid: boolean) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.isAreaValid = isValid;\r\n  //   setGlobalData(globalDataUpdate);\r\n  // };\r\n\r\n  // const updateIsValidPosition = (isValid: boolean) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.isPositionValid = isValid;\r\n  //   setGlobalData(globalDataUpdate);\r\n  // };\r\n\r\n  // const updateIsShowingDetectedContour = (isShowing: boolean) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.config.debug.isShowingDetectedContour =\r\n  //     isShowing;\r\n  //   setGlobalData(globalDataUpdate);\r\n  //   setIsShowingDetectedContour(isShowing);\r\n  // };\r\n\r\n  // const updateIsShowingDetectedGlare = (isShowing: boolean) => {\r\n  //   const globalDataUpdate = globalData;\r\n  //   globalDataUpdate.autoCapture.config.debug = isShowing;\r\n  //   setGlobalData(globalDataUpdate);\r\n  //   setIsShowingDetectedGlare(isShowing);\r\n  // };\r\n\r\n  const runScreenReader = () => {\r\n    const guideText = guideRef.current?.innerText;\r\n    const screenReaderText = screenReaderRef.current?.innerText;\r\n\r\n    if (\r\n      screenReaderText !== guideText &&\r\n      screenReaderRef.current &&\r\n      guideRef.current\r\n    ) {\r\n      screenReaderRef.current && guideText\r\n        ? (screenReaderRef.current.innerText = guideText)\r\n        : (screenReaderRef.current.innerText = '');\r\n    }\r\n  };\r\n\r\n  const videoStarted = () => {\r\n    // seems to have issues on ios without delay\r\n    setTimeout(() => {\r\n      initialiseCanvas();\r\n      animationManager.registerTask(renderVideo, 60);\r\n      // !! BUG: detection canvas renders the whole video instead of just the detection bits\r\n\r\n      animationManager.registerTask(\r\n        () =>\r\n          runDetection(\r\n            videoRef,\r\n            canvasDebugRef,\r\n            globalData.autoCapture,\r\n            setGlobalData,\r\n          ),\r\n        20,\r\n      );\r\n      // animationManager.registerTask(runCapturing, 2);\r\n      // !! The timing of validation should match timing of the continous position validation. for example runValidation,10 = vlidatePositionContinously, 100. This gives the best real time output.\r\n      animationManager.registerTask(runValidations, 10);\r\n      // animationManager.registerTask(runScreenReader, 10);\r\n    }, 2000);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ position: 'relative' }}>\r\n        <div ref={videoWrapperRef}>\r\n          <Webcam\r\n            videoConstraints={videoConstraints}\r\n            ref={videoRef}\r\n            onUserMedia={videoStarted}\r\n            style={{ position: 'absolute' }}\r\n          />\r\n        </div>\r\n        <div\r\n          ref={canvasWrapperRef}\r\n          style={{ position: 'relative' }}\r\n        >\r\n          {/* Video canvas */}\r\n          <canvas\r\n            id=\"canvasOutput\"\r\n            ref={canvasRef}\r\n            style={{ position: 'absolute' }}\r\n          ></canvas>\r\n\r\n          {/* Guidance frame + debug canvas */}\r\n          <canvas\r\n            id=\"canvasDebug\"\r\n            ref={canvasDebugRef}\r\n            style={{ position: 'absolute' }}\r\n          ></canvas>\r\n\r\n          <div\r\n            ref={guideRef}\r\n            id=\"guidance\"\r\n            style={{\r\n              position: 'absolute',\r\n              color: 'white',\r\n              textAlign: 'center',\r\n              bottom: '40px',\r\n              width: '100%',\r\n            }}\r\n          >\r\n            Position document inside boundary\r\n          </div>\r\n          <div\r\n            ref={screenReaderRef}\r\n            role=\"alert\"\r\n            style={{\r\n              clipPath: 'inset(50%)',\r\n              height: '1px',\r\n              overflow: 'hidden',\r\n              position: 'absolute',\r\n              whiteSpace: 'nowrap',\r\n              width: '1px',\r\n            }}\r\n          >\r\n            Position document inside boundary\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div style={{ position: 'relative' }}>\r\n        <a href=\"/camster\">Back to settings</a>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Camera;\r\n"],"names":["getGuidancePoints","detection","width","height","boxWidth","Math","round","boxHeight","widthFactor","isMobile","heightFactor","topLeft","cv","topRight","bottomLeft","drawGuidanceFrame","canvas","points","constructor","config","_this","autoCaptureConfig","preprocessImage","source","output","arguments","length","undefined","kernelSize","max","floor","min","rows","cols","intensityThresholds","calculateIntensityThresholds","morphKernel","lowerScalar","upperScalar","meanIntensity","this","features","find","f","factoryName","validate","imageData","detectedContour","detectDocument","isValid","draw","contour","pointArray","flatMap","p","x","y","push_back","isClosed","color","thickness","delete","getFeedback","updateConfig","setFunction","detectContours","contoursVec","hierarchy","largestContourPoints","_topLeftPoint","_topLeftPoint2","_topRightPoint","_topRightPoint2","_bottomRightPoint","_bottomRightPoint2","_bottomLeftPoint","_bottomLeftPoint2","center","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","i","data32S","point","distance","hypot","push","getCornerPoints","findBiggestContour","minimumDetectableArea","minAreaThreshold","maxArea","largestContour","size","get","area","peri","approx","isQuadrilateral","_detectedGlare","Error","glareContours","detectGlare","error","contoursMatVector","brightnessThreshold","gray","glareHierarchy","mask","zeros","ZoomAction","featureList","ContourDetection","glare","GlareDetection","position","contourDetectionConfig","zoomAction","guidanceBounds","detectedBounds","calculatePointLineDistances","lastDetectedPoints","guidancePoints","distances","calculatePointLineDistance","lineStart","lineEnd","sqrt","getBounds","minX","map","maxX","minY","maxY","Problem","margin","validation","sideDetectionMargin","every","num","ZoomOut","some","ZoomIn","MoveLeft","MoveRight","MoveUp","MoveDown","None","distanceFromBorder","leftLineStartPoint","leftLineEndPoint","rightLineStartPoint","rightLineEndPoint","runDetection","videoRef","canvasRef","setGlobalData","_videoRef$current","current","video","type","feedback","videoWidth","videoHeight","src","read","drawMat","getContext","clearRect","featuresToUse","activeFeatures","detectionResults","forEach","featuresType","srcClone","clone","feature","createFeature","Feature","result","debug","splice","FeatureValidationStatus","ValidationService","guidanceService","validationStatus","timeElapsed","timerId","isPictureTaken","validateFeatures","async","invalidResults","filter","r","All","Some","updateGuidanceWithDefaultMessage","resetTimer","updateGuidanceWithInvalidFeedback","Promise","setTimeout","updateGuidanceWithHoldSteadyMessage","validatePositionContinously","updateGuidanceWithSuccessMessage","updateGuidanceWithResetMessage","onSucess","onRestart","window","setInterval","console","log","holdingTime","clearInterval","GuidanceService","guideRef","defaultMessage","holdSteadyMessage","updateGuidance","message","innerText","UniqueNameSet","Set","values","super","names","value","includes","name","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","task","requestAnimationFrame","registerTask","add","toString","unregisterTask","cancelAnimationFrame","globalData","useGlobalContext","videoWrapperRef","React","canvasWrapperRef","useRef","canvasDebugRef","screenReaderRef","videoConstraints","getVideoConstraints","facingMode","exact","ideal","innerHeight","screen","initialiseCanvas","setupCanvasSize","canvasWrapper","style","detectionFrame","autoCapture","renderVideo","renderVideoToCanvas","_videoRef$current2","canv","getCanvas","willReadFrequently","drawImage","img","guidanceSercice","validationService","runValidations","_jsxs","children","_jsx","ref","Webcam","onUserMedia","videoStarted","id","textAlign","bottom","role","clipPath","overflow","whiteSpace","href"],"sourceRoot":""}