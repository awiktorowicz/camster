{"version":3,"file":"static/js/93.2cff9670.chunk.js","mappings":"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","sources":["components/Camera/CameraContext.ts","components/Camera/AutoCapture/AnimationManger.ts","components/Camera/AutoCapture/utils.ts","components/Camera/AutoCapture/index.tsx","components/Camera/index.tsx"],"sourcesContent":["import { createContext } from 'react';\r\n\r\nexport const CameraContext = createContext<any>({});\r\n","class UniqueNameSet extends Set {\r\n    constructor(values: any) {\r\n      super(values);\r\n  \r\n      const names: any = [];\r\n      for (let value of this) {\r\n        if (names.includes(value.name)) {\r\n          this.delete(value);\r\n        } else {\r\n          names.push(value.name);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  class AnimationManager {\r\n    private tasks: any = new UniqueNameSet([]);\r\n    private fps: number = 60; // Target FPS\r\n    private lastFrameTime: number = performance.now();\r\n    private animationId: number | null = null; // Store the animation frame ID\r\n  \r\n    private run = (currentTime: number) => {\r\n      const deltaTime = currentTime - this.lastFrameTime;\r\n  \r\n      // Ensure the tasks only run if enough time has passed to meet the target FPS\r\n      if (deltaTime > 1000 / this.fps) {\r\n        this.tasks.forEach((task: any) => {\r\n          const taskDeltaTime = currentTime - task.lastFrameTime;\r\n          if (taskDeltaTime > 1000 / task.fps) {\r\n            task.task(currentTime);\r\n            task.lastFrameTime = currentTime;\r\n          }\r\n        });\r\n        this.lastFrameTime = currentTime;\r\n      }\r\n  \r\n      this.animationId = requestAnimationFrame(this.run);\r\n    };\r\n  \r\n    public registerTask(task: FrameRequestCallback, fps: number) {\r\n      this.tasks.add({ task, fps, name: task.toString(), lastFrameTime: 0 });\r\n      if (this.tasks.size === 1) {\r\n        this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\r\n      }\r\n    }\r\n  \r\n    public unregisterTask(task: FrameRequestCallback) {\r\n      this.tasks.delete(task);\r\n      if (this.tasks.size === 0 && this.animationId !== null) {\r\n        cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\r\n        this.animationId = null; // Reset the ID\r\n      }\r\n    }\r\n  }\r\n  \r\n  export const animationManager = new AnimationManager();\r\n  ","import cv from '@techstark/opencv-js';\r\nimport { isMobile } from 'react-device-detect';\r\n\r\nexport const setupCanvasSize = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  canvasWrapperRef: any,\r\n) => {\r\n  const video = videoRef?.current?.video;\r\n  const canvas = canvasRef.current;\r\n  canvas.width = video.videoWidth;\r\n  canvas.height = video.videoHeight;\r\n  const canvasWrapper = canvasWrapperRef.current;\r\n  canvasWrapper.style.width = `${video.videoWidth}px`;\r\n  canvasWrapper.style.height = `${video.videoHeight}px`;\r\n};\r\n\r\nexport const getGuidancePoints = (\r\n  detectionFrameWidth: number,\r\n  detectionFrameHeight: number,\r\n  width: number,\r\n  height: number,\r\n) => {\r\n  const boxWidth = Math.round(width * (detectionFrameWidth / 100));\r\n  const boxHeight = Math.round(height * (detectionFrameHeight / 100));\r\n\r\n  const widthFactor = isMobile ? boxWidth / 2 : boxWidth / 4;\r\n\r\n  const heightFactor = boxHeight / 2;\r\n\r\n  const topLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const topRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const bottomLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n  const bottomRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n\r\n  return [topLeft, topRight, bottomRight, bottomLeft];\r\n};\r\n\r\n//TODO: Seperate drawing logic\r\nexport const renderVideoToCanvas = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  detectionFrameWidth: number,\r\n  detectionFrameHeight: number,\r\n  detectedPoints: Array<any>,\r\n  debug: boolean,\r\n) => {\r\n  const canv = videoRef?.current?.getCanvas();\r\n  if (canv) {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n    ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\r\n\r\n    const img = cv.imread(canvasRef.current);\r\n\r\n    if (debug && detectedPoints.length === 4) {\r\n      // console.log(detectedPoints);\r\n      const red = [255, 0, 0, 255];\r\n      cv.rectangle(img, detectedPoints[0], detectedPoints[2], red, 2);\r\n    }\r\n\r\n    cv.imshow(canvasRef.current, img);\r\n\r\n    img.delete();\r\n\r\n    //setDocDetected(true);\r\n  }\r\n};\r\n\r\nexport const detectDocumentPoints = (videoRef: any) => {\r\n  const video = videoRef.current.video;\r\n  video.height = video.videoHeight;\r\n  video.width = video.videoWidth;\r\n  const cap = new cv.VideoCapture(video);\r\n  const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\r\n  cap.read(src);\r\n\r\n  cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);\r\n\r\n  // Apply gaussian blur\r\n  let kernelSize = Math.max(3, Math.floor(Math.min(src.rows, src.cols) / 100));\r\n  cv.GaussianBlur(src, src, new cv.Size(kernelSize, kernelSize), 0, 0);\r\n\r\n  const lowerScalar = 0.66;\r\n  const upperScalar = 1.33;\r\n\r\n  let meanIntensity = cv.mean(src)[0];\r\n  let lowerThreshold = lowerScalar * meanIntensity;\r\n  let upperThreshold = upperScalar * meanIntensity;\r\n  const intensityThresholds = [lowerThreshold, upperThreshold];\r\n\r\n  // Apply canny edge\r\n  cv.Canny(src, src, intensityThresholds[0], intensityThresholds[1]);\r\n\r\n  // Apply morphology closing\r\n  let morphKernel = cv.getStructuringElement(\r\n    cv.MORPH_ELLIPSE,\r\n    new cv.Size(5, 5),\r\n  );\r\n  cv.morphologyEx(src, src, cv.MORPH_CLOSE, morphKernel);\r\n\r\n  let contoursVec = new cv.MatVector();\r\n  let hierarchy = new cv.Mat();\r\n\r\n  cv.findContours(\r\n    src,\r\n    contoursVec,\r\n    hierarchy,\r\n    cv.RETR_EXTERNAL,\r\n    cv.CHAIN_APPROX_SIMPLE,\r\n  );\r\n\r\n  let largestContour = findBiggestContour(contoursVec, 5000);\r\n  let largestContourPoints = getCornerPoints(largestContour);\r\n\r\n  hierarchy.delete();\r\n  contoursVec.delete();\r\n  src.delete();\r\n\r\n  return largestContourPoints;\r\n};\r\n\r\nconst findBiggestContour = (\r\n  contoursVec: cv.MatVector,\r\n  minAreaThreshold: number,\r\n) => {\r\n  // maxArea is used to store the biggest area and the initial value is used to reduce noise.\r\n  let maxArea = minAreaThreshold;\r\n  let largestContour = null;\r\n\r\n  for (let i = 0; i < contoursVec.size(); ++i) {\r\n    let contour = contoursVec.get(i);\r\n    let area = cv.contourArea(contour);\r\n\r\n    if (area < minAreaThreshold) {\r\n      contour.delete();\r\n      continue;\r\n    }\r\n\r\n    let peri = cv.arcLength(contour, true);\r\n    let approx = new cv.Mat();\r\n    cv.approxPolyDP(contour, approx, 0.02 * peri, true);\r\n\r\n    const isQuadrilateral = approx && approx.rows === 4;\r\n\r\n    if (area > maxArea && isQuadrilateral) {\r\n      if (largestContour) largestContour.delete();\r\n      largestContour = approx;\r\n      maxArea = area;\r\n    } else {\r\n      approx.delete();\r\n    }\r\n\r\n    contour.delete();\r\n  }\r\n\r\n  return largestContour;\r\n};\r\n\r\nconst getCornerPoints = (contour: any) => {\r\n  if (!contour) return null;\r\n\r\n  let points: cv.Point[] = [];\r\n  let rect = cv.minAreaRect(contour);\r\n  const center = rect.center;\r\n\r\n  let topLeftPoint;\r\n  let topLeftDistance = 0;\r\n\r\n  let topRightPoint;\r\n  let topRightDistance = 0;\r\n\r\n  let bottomLeftPoint;\r\n  let bottomLeftDistance = 0;\r\n\r\n  let bottomRightPoint;\r\n  let bottomRightDistance = 0;\r\n\r\n  for (let i = 0; i < contour.data32S.length; i += 2) {\r\n    const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\r\n    const distance = Math.hypot(point.x - center.x, point.y - center.y);\r\n    if (point.x < center.x && point.y < center.y) {\r\n      if (distance > topLeftDistance) {\r\n        topLeftPoint = point;\r\n        topLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y < center.y) {\r\n      if (distance > topRightDistance) {\r\n        topRightPoint = point;\r\n        topRightDistance = distance;\r\n      }\r\n    } else if (point.x < center.x && point.y > center.y) {\r\n      if (distance > bottomLeftDistance) {\r\n        bottomLeftPoint = point;\r\n        bottomLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y > center.y) {\r\n      if (distance > bottomRightDistance) {\r\n        bottomRightPoint = point;\r\n        bottomRightDistance = distance;\r\n      }\r\n    }\r\n  }\r\n\r\n  points.push(new cv.Point(topLeftPoint?.x, topLeftPoint?.y));\r\n  points.push(new cv.Point(topRightPoint?.x, topRightPoint?.y));\r\n  points.push(new cv.Point(bottomRightPoint?.x, bottomRightPoint?.y));\r\n  points.push(new cv.Point(bottomLeftPoint?.x, bottomLeftPoint?.y));\r\n  return points;\r\n};\r\n\r\nexport const calculatePointLineDistances = (\r\n  lastDetectedPoints: cv.Point[] | null,\r\n  guidancePoints: cv.Point[] | null,\r\n) => {\r\n  if (!lastDetectedPoints || !guidancePoints) return [];\r\n\r\n  let distances = [];\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[0],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[1],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[2],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[3],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n  return distances;\r\n};\r\n\r\nconst calculatePointLineDistance = (\r\n  point: cv.Point,\r\n  lineStart: cv.Point,\r\n  lineEnd: cv.Point,\r\n) => {\r\n  // Absolute value is not calculated on purpose\r\n  let numerator =\r\n    (lineEnd.y - lineStart.y) * point.x -\r\n    (lineEnd.x - lineStart.x) * point.y +\r\n    lineEnd.x * lineStart.y -\r\n    lineEnd.y * lineStart.x;\r\n  let denominator = Math.sqrt(\r\n    (lineEnd.y - lineStart.y) ** 2 + (lineEnd.x - lineStart.x) ** 2,\r\n  );\r\n\r\n  return numerator / denominator;\r\n};\r\n\r\nexport const validatePoints = (detectedPoints: any, guidancePoints: any) => {\r\n  const distances = calculatePointLineDistances(detectedPoints, guidancePoints);\r\n  const margin = 20;\r\n  let width = guidancePoints[1].x - guidancePoints[0].x;\r\n  if (distances.every((num) => num < 0)) {\r\n    return { isValid: false, action: 'zoom out' };\r\n  }\r\n\r\n  if (distances.every((num) => num >= 0)) {\r\n    if (distances.some((distance) => distance / width > margin / 100)) {\r\n      return { isValid: false, action: 'zoom in' };\r\n    }\r\n  }\r\n\r\n  const guidanceBounds = getBounds(guidancePoints);\r\n  const detectedBounds = getBounds(detectedPoints);\r\n\r\n  if (!detectedBounds || !guidanceBounds) return { isValid: false };\r\n\r\n  if (detectedBounds.minX < guidanceBounds.minX) {\r\n    return { isValid: false, action: 'move left' };\r\n  }\r\n\r\n  if (detectedBounds.maxX > guidanceBounds.maxX) {\r\n    return { isValid: false, action: 'move right' };\r\n  }\r\n\r\n  // Check up-down\r\n  if (detectedBounds.minY < guidanceBounds.minY) {\r\n    return { isValid: false, action: 'move up' };\r\n  }\r\n\r\n  if (detectedBounds.maxY > guidanceBounds.maxY) {\r\n    return { isValid: false, action: 'move down' };\r\n  }\r\n\r\n  return { isValid: true };\r\n};\r\n\r\nconst getBounds = (points: cv.Point[] | null) => {\r\n  if (!points) return null;\r\n\r\n  const minX = Math.min(...points.map((point) => point.x));\r\n  const maxX = Math.max(...points.map((point) => point.x));\r\n  const minY = Math.min(...points.map((point) => point.y));\r\n  const maxY = Math.max(...points.map((point) => point.y));\r\n\r\n  return { minX, maxX, minY, maxY };\r\n};\r\n","import React, {\r\n  forwardRef,\r\n  useContext,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\nimport { CameraContext } from '../CameraContext';\r\nimport { animationManager } from './AnimationManger';\r\nimport AutoCaptureProps from './interface';\r\nimport {\r\n  detectDocumentPoints,\r\n  getGuidancePoints,\r\n  renderVideoToCanvas,\r\n  setupCanvasSize,\r\n  validatePoints,\r\n} from './utils';\r\n\r\nconst AutoCapture = forwardRef<any, AutoCaptureProps>(\r\n  (\r\n    {\r\n      debug = false,\r\n      detectionFrameWidth = 75,\r\n      detectionFrameHeight = 75,\r\n      videoRef,\r\n    },\r\n    ref,\r\n  ) => {\r\n    const { docDetected, setDocDetected } = useContext(CameraContext);\r\n    let detectedPoints: any = [];\r\n    let noDetectionCounter: number = 0;\r\n\r\n    let canvas: any;\r\n    let guidancePoints: any;\r\n\r\n    const [guidanceMsg, setGuidanceMsg] = useState<string>(\r\n      'Position document inside boundary',\r\n    );\r\n\r\n    const canvasWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const canvasDebugRef = useRef<HTMLCanvasElement | null>(null);\r\n    const guideRef = React.useRef<HTMLDivElement | null>(null);\r\n    const screenReaderRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      videoStarted: () => {\r\n        initialiseCanvas();\r\n        animationManager.registerTask(renderVideo, 60);\r\n        animationManager.registerTask(detectDocument, 10);\r\n      },\r\n    }));\r\n\r\n    const initialiseCanvas = () => {\r\n      setupCanvasSize(videoRef, canvasRef, canvasWrapperRef);\r\n      canvas = canvasRef.current ? canvasRef.current : { width: 0, height: 0 };\r\n      guidancePoints = getGuidancePoints(\r\n        detectionFrameWidth,\r\n        detectionFrameHeight,\r\n        canvas.width,\r\n        canvas.height,\r\n      );\r\n    };\r\n\r\n    const renderVideo = () => {\r\n      renderVideoToCanvas(\r\n        videoRef,\r\n        canvasRef,\r\n        detectionFrameWidth,\r\n        detectionFrameHeight,\r\n        detectedPoints,\r\n        debug,\r\n      );\r\n    };\r\n\r\n    const detectDocument = () => {\r\n      const largestPointsDetected = detectDocumentPoints(videoRef);\r\n\r\n      if (largestPointsDetected?.length === 4) {\r\n        detectedPoints = largestPointsDetected;\r\n        const isValid = validatePoints(detectedPoints, guidancePoints);\r\n        // console.log(isValid);\r\n        if (isValid.isValid) {\r\n          setDocDetected(true);\r\n          setGuidanceMsg('capturing');\r\n        } else {\r\n          setDocDetected(false);\r\n          setGuidanceMsg(\r\n            isValid.action\r\n              ? isValid.action\r\n              : 'Position document inside boundary',\r\n          );\r\n        }\r\n      } else {\r\n        noDetectionCounter += 1;\r\n      }\r\n      if (noDetectionCounter > 10) {\r\n        noDetectionCounter = 0;\r\n        detectedPoints = [];\r\n        setDocDetected(false);\r\n        setGuidanceMsg('Position document inside boundary');\r\n      }\r\n    };\r\n\r\n    return (\r\n      <div\r\n        ref={canvasWrapperRef}\r\n        style={{ position: 'relative' }}\r\n      >\r\n        {/* Video canvas */}\r\n        <canvas\r\n          id=\"canvasOutput\"\r\n          ref={canvasRef}\r\n          style={{ position: 'absolute' }}\r\n        ></canvas>\r\n\r\n        {/* Guidance frame + debug canvas */}\r\n        <canvas\r\n          id=\"canvasDebug\"\r\n          ref={canvasDebugRef}\r\n          style={{ position: 'absolute' }}\r\n        ></canvas>\r\n\r\n        <div\r\n          ref={guideRef}\r\n          id=\"guidance\"\r\n          style={{\r\n            position: 'absolute',\r\n            color: 'white',\r\n            textAlign: 'center',\r\n            bottom: '40px',\r\n            width: '100%',\r\n          }}\r\n        >\r\n          {guidanceMsg}\r\n        </div>\r\n        <div\r\n          ref={screenReaderRef}\r\n          role=\"alert\"\r\n          style={{\r\n            clipPath: 'inset(50%)',\r\n            height: '1px',\r\n            overflow: 'hidden',\r\n            position: 'absolute',\r\n            whiteSpace: 'nowrap',\r\n            width: '1px',\r\n          }}\r\n        >\r\n          {guidanceMsg}\r\n        </div>\r\n      </div>\r\n    );\r\n  },\r\n);\r\n\r\nexport default AutoCapture;\r\n","import React, { useRef, useState, useContext, createContext } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { isMobile } from 'react-device-detect';\r\n\r\nimport { CameraContext } from './CameraContext';\r\nimport AutoCapture from './AutoCapture';\r\n\r\nconst Camera = (props: any) => {\r\n\r\n  // console.log(props);\r\n\r\n  const [docDetected, setDocDetected] = useState(false);\r\n\r\n  let autocaptureProps = {};\r\n  if(props && props.autoCapture) {\r\n    autocaptureProps = props.autoCapture;\r\n  }\r\n\r\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const videoRef = React.useRef<Webcam>(null);\r\n  const AutoCaptureRef = useRef<any>(null);\r\n\r\n  const [videoWidth, setVideoWidth] = useState<number>(0);\r\n  const [videoHeight, setVideoHeight] = useState<number>(0);\r\n\r\n  const [guidanceWidth, setGuidanceWidth] = useState<number>(0);\r\n  const [guidanceHeight, setGuidanceHeight] = useState<number>(0);\r\n\r\n  const getVideoConstraints = () => {\r\n    let videoConstraints = {\r\n      facingMode: 'user',\r\n      width: { ideal: 1280 },\r\n      height: { ideal: 720 },\r\n    };\r\n    if (isMobile) {\r\n      videoConstraints = {\r\n        facingMode: 'environment',\r\n        width: { ideal: window.innerHeight },\r\n        height: { ideal: window.screen.width },\r\n      };\r\n    }\r\n    return videoConstraints;\r\n  };\r\n\r\n  const drawGuidanceFrame = () => {\r\n    const videoWidth = videoRef.current?.video?.videoWidth ? videoRef.current?.video?.videoWidth : 0;\r\n    const videoHeight = videoRef.current?.video?.videoHeight ? videoRef.current?.video?.videoHeight : 0;\r\n\r\n    const widthFactor = isMobile ? 1 : 2;\r\n\r\n    setGuidanceWidth(Math.round(videoWidth * (props.autoCapture.detectionFrameWidth / 100)) / widthFactor);\r\n    setGuidanceHeight(Math.round(videoHeight * (props.autoCapture.detectionFrameHeight / 100)));\r\n\r\n    //console.log(Math.round(videoWidth * (props.autoCapture.detectionFrameWidth / 100)) / widthFactor);\r\n    //console.log(videoHeight * (props.autoCapture.detectionFrameHeight / 100));\r\n  }\r\n\r\n  const videoStarted = () => {\r\n    // seems to have issues on ios without delay\r\n    setTimeout(() => {\r\n      if (AutoCaptureRef.current) {\r\n        setVideoWidth(videoRef.current?.video?.videoWidth ? videoRef.current?.video?.videoWidth : 0);\r\n        setVideoHeight(videoRef.current?.video?.videoHeight ? videoRef.current?.video?.videoHeight : 0);\r\n        drawGuidanceFrame();\r\n        AutoCaptureRef.current.videoStarted();\r\n      }\r\n    }, 2000);\r\n  };\r\n\r\n  const videoConstraints = getVideoConstraints();\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ position: 'relative' }}>\r\n        \r\n        {/* react webcam component */}\r\n        <div ref={videoWrapperRef}>\r\n          <Webcam\r\n            videoConstraints={videoConstraints}\r\n            ref={videoRef}\r\n            style={{ position: 'absolute' }}\r\n            onUserMedia={videoStarted}\r\n          />\r\n        </div>\r\n        {/* guidance frame */}\r\n        <div style={{ position: 'absolute', zIndex: 2, width: videoWidth, height: videoHeight }}>\r\n          { guidanceWidth && guidanceHeight ?\r\n          <svg width={videoWidth} height={videoHeight} xmlns=\"http://www.w3.org/2000/svg\">\r\n            <defs>\r\n              <mask id=\"mask1\">\r\n                <rect mask=\"url(#mask1)\" width={videoWidth} height={videoHeight} x=\"0\" y=\"0\" style={{ fill: 'white', stroke:'none', strokeWidth:5, opacity:0.5 }} />\r\n                <rect width={guidanceWidth} height={guidanceHeight} x={videoWidth / 2 - guidanceWidth / 2} y={videoHeight / 2 - guidanceHeight / 2} rx=\"20\" ry=\"20\" />\r\n              </mask>\r\n            </defs>\r\n            <rect mask=\"url(#mask1)\" width={videoWidth} height={videoHeight} x=\"0\" y=\"0\" style={{ fill: 'white', stroke:'none', strokeWidth:5, opacity:0.5 }} />\r\n            <rect width={guidanceWidth} height={guidanceHeight} x={videoWidth / 2 - guidanceWidth / 2} y={videoHeight / 2 - guidanceHeight / 2} rx=\"20\" ry=\"20\" style={{ fill: 'none', stroke:docDetected ? 'green' : 'black', strokeWidth:5, opacity:1 }} />\r\n          </svg>\r\n           : null }\r\n        </div>\r\n        {/* auto capture */}\r\n        <div style={{ position: 'absolute', zIndex: 1 }}>\r\n        <CameraContext.Provider value={{docDetected, setDocDetected}}>\r\n          <AutoCapture {...autocaptureProps} ref={AutoCaptureRef} videoRef={videoRef} />\r\n        </CameraContext.Provider>\r\n        </div>\r\n\r\n      </div>\r\n\r\n      <div style={{ position: 'relative', zIndex: 3 }}>\r\n        <a href=\"/camster\">Back to settings</a>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Camera;\r\n"],"names":["CameraContext","createContext","UniqueNameSet","Set","constructor","values","super","names","value","this","includes","name","delete","push","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","forEach","task","requestAnimationFrame","registerTask","add","toString","size","unregisterTask","cancelAnimationFrame","findBiggestContour","contoursVec","minAreaThreshold","maxArea","largestContour","i","contour","get","area","cv","peri","approx","isQuadrilateral","rows","getCornerPoints","_topLeftPoint","_topLeftPoint2","_topRightPoint","_topRightPoint2","_bottomRightPoint","_bottomRightPoint2","_bottomLeftPoint","_bottomLeftPoint2","points","center","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","data32S","length","point","x","y","distance","Math","hypot","calculatePointLineDistance","lineStart","lineEnd","sqrt","validatePoints","detectedPoints","guidancePoints","distances","calculatePointLineDistances","lastDetectedPoints","width","every","num","isValid","action","some","margin","guidanceBounds","getBounds","detectedBounds","minX","maxX","minY","maxY","min","map","max","forwardRef","_ref","ref","debug","detectionFrameWidth","detectionFrameHeight","videoRef","docDetected","setDocDetected","useContext","canvas","noDetectionCounter","guidanceMsg","setGuidanceMsg","useState","canvasWrapperRef","React","canvasRef","useRef","canvasDebugRef","guideRef","screenReaderRef","useImperativeHandle","videoStarted","initialiseCanvas","renderVideo","detectDocument","setupCanvasSize","_videoRef$current","video","current","videoWidth","height","videoHeight","canvasWrapper","style","getGuidancePoints","boxWidth","round","boxHeight","widthFactor","isMobile","heightFactor","topLeft","topRight","bottomLeft","renderVideoToCanvas","_videoRef$current2","canv","getCanvas","getContext","willReadFrequently","drawImage","img","red","largestPointsDetected","cap","src","read","kernelSize","floor","cols","meanIntensity","intensityThresholds","morphKernel","hierarchy","largestContourPoints","detectDocumentPoints","_jsxs","position","children","_jsx","id","color","textAlign","bottom","role","clipPath","overflow","whiteSpace","props","autocaptureProps","autoCapture","videoWrapperRef","AutoCaptureRef","setVideoWidth","setVideoHeight","guidanceWidth","setGuidanceWidth","guidanceHeight","setGuidanceHeight","videoConstraints","getVideoConstraints","facingMode","ideal","window","innerHeight","screen","Webcam","onUserMedia","setTimeout","_videoRef$current5","_videoRef$current5$vi","_videoRef$current6","_videoRef$current6$vi","_videoRef$current7","_videoRef$current7$vi","_videoRef$current8","_videoRef$current8$vi","drawGuidanceFrame","_videoRef$current$vid","_videoRef$current2$vi","_videoRef$current3","_videoRef$current3$vi","_videoRef$current4","_videoRef$current4$vi","zIndex","xmlns","mask","fill","stroke","strokeWidth","opacity","rx","ry","Provider","AutoCapture","href"],"sourceRoot":""}