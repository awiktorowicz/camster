{"version":3,"file":"static/js/93.6d8bb0d3.chunk.js","mappings":"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","sources":["components/Camera/CameraContext.ts","components/Camera/AutoCapture/utils.ts","components/Camera/AutoCapture/AnimationManger.ts","components/Camera/AutoCapture/index.tsx","components/Camera/index.tsx"],"sourcesContent":["import { createContext } from 'react';\r\n\r\nexport const CameraContext = createContext<any>({});\r\n","import cv from '@techstark/opencv-js';\r\nimport { isMobile } from 'react-device-detect';\r\n\r\nexport const setupCanvasSize = (\r\n    videoRef: any,\r\n    canvasRef: any,\r\n    canvasWrapperRef: any\r\n  ) => {\r\n    const video = videoRef?.current?.video;\r\n    const canvas = canvasRef.current;\r\n    canvas.width = video.videoWidth;\r\n    canvas.height = video.videoHeight;\r\n    const canvasWrapper = canvasWrapperRef.current;\r\n    canvasWrapper.style.width = `${video.videoWidth}px`;\r\n    canvasWrapper.style.height = `${video.videoHeight}px`;\r\n};\r\n\r\nexport const getGuidancePoints = (detectionFrameWidth: number, detectionFrameHeight: number, width: number, height: number) => {\r\n  const boxWidth = Math.round(width * (detectionFrameWidth / 100));\r\n  const boxHeight = Math.round(height * (detectionFrameHeight / 100));\r\n\r\n  const widthFactor = isMobile ? boxWidth / 2 : boxWidth / 4;\r\n\r\n  const heightFactor = boxHeight / 2;\r\n\r\n  const topLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const topRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const bottomLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n  const bottomRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n\r\n  return [topLeft, topRight, bottomRight, bottomLeft];\r\n};\r\n\r\n//TODO: Seperate drawing logic\r\nexport const renderVideoToCanvas = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  detectionFrameWidth: number,\r\n  detectionFrameHeight: number,\r\n  detectedPoints: Array<any>,\r\n  debug: boolean\r\n) => {\r\n  const canv = videoRef?.current?.getCanvas();\r\n  if (canv) {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n    ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\r\n\r\n    const img = cv.imread(canvasRef.current);\r\n\r\n    if (debug && detectedPoints.length === 4) {\r\n      // console.log(detectedPoints);\r\n      const red = [255, 0, 0, 255];\r\n      cv.rectangle(img, detectedPoints[0], detectedPoints[2], red, 2);\r\n    }\r\n\r\n    cv.imshow(canvasRef.current, img);\r\n\r\n    img.delete();\r\n\r\n    //setDocDetected(true);\r\n  }\r\n};\r\n\r\nexport const detectDocumentPoints = (canvasRef: any) => {\r\n  \r\n  let src = cv.imread(canvasRef.current);\r\n  cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);\r\n\r\n  // Apply gaussian blur\r\n  let kernelSize = Math.max(\r\n    3,\r\n    Math.floor(Math.min(src.rows, src.cols) / 100),\r\n  );\r\n  cv.GaussianBlur(src, src, new cv.Size(kernelSize, kernelSize), 0, 0);\r\n\r\n  const lowerScalar = 0.66;\r\n  const upperScalar = 1.33;\r\n\r\n  let meanIntensity = cv.mean(src)[0];\r\n  let lowerThreshold = lowerScalar * meanIntensity;\r\n  let upperThreshold = upperScalar * meanIntensity;\r\n  const intensityThresholds = [lowerThreshold, upperThreshold];\r\n\r\n  // Apply canny edge\r\n  cv.Canny(src, src, intensityThresholds[0], intensityThresholds[1]);\r\n\r\n  // Apply morphology closing\r\n  let morphKernel = cv.getStructuringElement(\r\n    cv.MORPH_ELLIPSE,\r\n    new cv.Size(5, 5),\r\n  );\r\n  cv.morphologyEx(src, src, cv.MORPH_CLOSE, morphKernel);\r\n\r\n  let contoursVec = new cv.MatVector();\r\n  let hierarchy = new cv.Mat();\r\n\r\n  cv.findContours(\r\n    src,\r\n    contoursVec,\r\n    hierarchy,\r\n    cv.RETR_EXTERNAL,\r\n    cv.CHAIN_APPROX_SIMPLE,\r\n  );\r\n\r\n  let largestContour = findBiggestContour(\r\n    contoursVec,\r\n    5000,\r\n  );\r\n  let largestContourPoints = getCornerPoints(largestContour);\r\n\r\n  hierarchy.delete();\r\n  contoursVec.delete();\r\n  src.delete();\r\n\r\n  return largestContourPoints;\r\n  \r\n};\r\n\r\nconst findBiggestContour = (contoursVec: cv.MatVector, minAreaThreshold: number) => {\r\n  // maxArea is used to store the biggest area and the initial value is used to reduce noise.\r\n  let maxArea = minAreaThreshold;\r\n  let largestContour = null;\r\n\r\n  for (let i = 0; i < contoursVec.size(); ++i) {\r\n    let contour = contoursVec.get(i);\r\n    let area = cv.contourArea(contour);\r\n\r\n    if (area < minAreaThreshold) {\r\n      contour.delete();\r\n      continue;\r\n    }\r\n\r\n    let peri = cv.arcLength(contour, true);\r\n    let approx = new cv.Mat();\r\n    cv.approxPolyDP(contour, approx, 0.02 * peri, true);\r\n\r\n    const isQuadrilateral = approx && approx.rows === 4;\r\n\r\n    if (area > maxArea && isQuadrilateral) {\r\n      if (largestContour) largestContour.delete();\r\n      largestContour = approx;\r\n      maxArea = area;\r\n    } else {\r\n      approx.delete();\r\n    }\r\n\r\n    contour.delete();\r\n  }\r\n\r\n  return largestContour;\r\n};\r\n\r\nconst getCornerPoints = (contour: any) => {\r\n  if (!contour) return null;\r\n\r\n  let points: cv.Point[] = [];\r\n  let rect = cv.minAreaRect(contour);\r\n  const center = rect.center;\r\n\r\n  let topLeftPoint;\r\n  let topLeftDistance = 0;\r\n\r\n  let topRightPoint;\r\n  let topRightDistance = 0;\r\n\r\n  let bottomLeftPoint;\r\n  let bottomLeftDistance = 0;\r\n\r\n  let bottomRightPoint;\r\n  let bottomRightDistance = 0;\r\n\r\n  for (let i = 0; i < contour.data32S.length; i += 2) {\r\n    const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\r\n    const distance = Math.hypot(point.x - center.x, point.y - center.y);\r\n    if (point.x < center.x && point.y < center.y) {\r\n      if (distance > topLeftDistance) {\r\n        topLeftPoint = point;\r\n        topLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y < center.y) {\r\n      if (distance > topRightDistance) {\r\n        topRightPoint = point;\r\n        topRightDistance = distance;\r\n      }\r\n    } else if (point.x < center.x && point.y > center.y) {\r\n      if (distance > bottomLeftDistance) {\r\n        bottomLeftPoint = point;\r\n        bottomLeftDistance = distance;\r\n      }\r\n    } else if (point.x > center.x && point.y > center.y) {\r\n      if (distance > bottomRightDistance) {\r\n        bottomRightPoint = point;\r\n        bottomRightDistance = distance;\r\n      }\r\n    }\r\n  }\r\n\r\n  points.push(new cv.Point(topLeftPoint?.x, topLeftPoint?.y));\r\n  points.push(new cv.Point(topRightPoint?.x, topRightPoint?.y));\r\n  points.push(new cv.Point(bottomRightPoint?.x, bottomRightPoint?.y));\r\n  points.push(new cv.Point(bottomLeftPoint?.x, bottomLeftPoint?.y));\r\n  return points;\r\n};\r\n\r\nexport const calculatePointLineDistances = (\r\n  lastDetectedPoints: cv.Point[] | null,\r\n  guidancePoints: cv.Point[] | null,\r\n) => {\r\n  if (!lastDetectedPoints || !guidancePoints) return [];\r\n\r\n  let distances = [];\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[0],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[1],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[2],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[3],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n  return distances;\r\n};\r\n\r\nconst calculatePointLineDistance = (\r\n  point: cv.Point,\r\n  lineStart: cv.Point,\r\n  lineEnd: cv.Point,\r\n) => {\r\n  // Absolute value is not calculated on purpose\r\n  let numerator =\r\n    (lineEnd.y - lineStart.y) * point.x -\r\n    (lineEnd.x - lineStart.x) * point.y +\r\n    lineEnd.x * lineStart.y -\r\n    lineEnd.y * lineStart.x;\r\n  let denominator = Math.sqrt(\r\n    (lineEnd.y - lineStart.y) ** 2 + (lineEnd.x - lineStart.x) ** 2,\r\n  );\r\n\r\n  return numerator / denominator;\r\n};\r\n\r\nexport const validatePoints = (detectedPoints: any, guidancePoints: any) => {\r\n  const distances = calculatePointLineDistances(\r\n    detectedPoints,\r\n    guidancePoints,\r\n  );\r\n  const margin = 20;\r\n  let width = guidancePoints[1].x - guidancePoints[0].x;\r\n  if (distances.every((num) => num < 0)) {\r\n    return { isValid: false, action: 'zoom out' };\r\n  }\r\n\r\n  if (distances.every((num) => num >= 0)) {\r\n    if (distances.some((distance) => distance / width > margin / 100)) {\r\n      return { isValid: false, action: 'zoom in' };\r\n    }\r\n  }\r\n\r\n  const guidanceBounds = getBounds(guidancePoints);\r\n  const detectedBounds = getBounds(detectedPoints);\r\n\r\n  if (!detectedBounds || !guidanceBounds) return { isValid: false };\r\n\r\n  if (detectedBounds.minX < guidanceBounds.minX) {\r\n    return { isValid: false, action: 'move left' };\r\n  }\r\n\r\n  if (detectedBounds.maxX > guidanceBounds.maxX) {\r\n    return { isValid: false, action: 'move right' };\r\n  }\r\n\r\n  // Check up-down\r\n  if (detectedBounds.minY < guidanceBounds.minY) {\r\n    return { isValid: false, action: 'move up' };\r\n  }\r\n\r\n  if (detectedBounds.maxY > guidanceBounds.maxY) {\r\n    return { isValid: false, action: 'move down' };\r\n  }\r\n\r\n  return { isValid: true };\r\n};\r\n\r\nconst getBounds = (points: cv.Point[] | null) => {\r\n  if (!points) return null;\r\n\r\n  const minX = Math.min(...points.map((point) => point.x));\r\n  const maxX = Math.max(...points.map((point) => point.x));\r\n  const minY = Math.min(...points.map((point) => point.y));\r\n  const maxY = Math.max(...points.map((point) => point.y));\r\n\r\n  return { minX, maxX, minY, maxY };\r\n};\r\n","class UniqueNameSet extends Set {\r\n    constructor(values: any) {\r\n      super(values);\r\n  \r\n      const names: any = [];\r\n      for (let value of this) {\r\n        if (names.includes(value.name)) {\r\n          this.delete(value);\r\n        } else {\r\n          names.push(value.name);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  class AnimationManager {\r\n    private tasks: any = new UniqueNameSet([]);\r\n    private fps: number = 60; // Target FPS\r\n    private lastFrameTime: number = performance.now();\r\n    private animationId: number | null = null; // Store the animation frame ID\r\n  \r\n    private run = (currentTime: number) => {\r\n      const deltaTime = currentTime - this.lastFrameTime;\r\n  \r\n      // Ensure the tasks only run if enough time has passed to meet the target FPS\r\n      if (deltaTime > 1000 / this.fps) {\r\n        this.tasks.forEach((task: any) => {\r\n          const taskDeltaTime = currentTime - task.lastFrameTime;\r\n          if (taskDeltaTime > 1000 / task.fps) {\r\n            task.task(currentTime);\r\n            task.lastFrameTime = currentTime;\r\n          }\r\n        });\r\n        this.lastFrameTime = currentTime;\r\n      }\r\n  \r\n      this.animationId = requestAnimationFrame(this.run);\r\n    };\r\n  \r\n    public registerTask(task: FrameRequestCallback, fps: number) {\r\n      this.tasks.add({ task, fps, name: task.toString(), lastFrameTime: 0 });\r\n      if (this.tasks.size === 1) {\r\n        this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\r\n      }\r\n    }\r\n  \r\n    public unregisterTask(task: FrameRequestCallback) {\r\n      this.tasks.delete(task);\r\n      if (this.tasks.size === 0 && this.animationId !== null) {\r\n        cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\r\n        this.animationId = null; // Reset the ID\r\n      }\r\n    }\r\n  }\r\n  \r\n  export const animationManager = new AnimationManager();\r\n  ","import React, { useRef, forwardRef, useImperativeHandle, useContext, useState } from 'react';\r\nimport AutoCaptureProps from './interface';\r\nimport { setupCanvasSize, renderVideoToCanvas, detectDocumentPoints, getGuidancePoints, calculatePointLineDistances, validatePoints  } from './utils';\r\nimport { animationManager } from './AnimationManger';\r\nimport { CameraContext } from '../CameraContext';\r\n\r\nconst AutoCapture = forwardRef<any, AutoCaptureProps>(({\r\n  debug = false,\r\n  detectionFrameWidth = 75,\r\n  detectionFrameHeight = 75,\r\n  videoRef\r\n}, ref) => {\r\n\r\n  const { docDetected, setDocDetected } = useContext(CameraContext);\r\n  let detectedPoints: any = [];\r\n  let noDetectionCounter: number = 0;\r\n\r\n  let canvas: any;\r\n  let guidancePoints: any;\r\n\r\n  const [guidanceMsg, setGuidanceMsg] = useState<string>('Position document inside boundary');\r\n\r\n  const canvasWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const canvasDebugRef = useRef<HTMLCanvasElement | null>(null);\r\n  const guideRef = React.useRef<HTMLDivElement | null>(null);\r\n  const screenReaderRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    videoStarted: () => {\r\n      initialiseCanvas();\r\n      animationManager.registerTask(renderVideo, 60);\r\n      animationManager.registerTask(detectDocument, 10);\r\n    }\r\n  }));\r\n\r\n  const initialiseCanvas = () => {\r\n    setupCanvasSize(\r\n      videoRef,\r\n      canvasRef,\r\n      canvasWrapperRef\r\n    );\r\n    canvas = canvasRef.current ? canvasRef.current : { width: 0, height: 0};\r\n    guidancePoints = getGuidancePoints(detectionFrameWidth, detectionFrameHeight, canvas.width, canvas.height);\r\n  };\r\n\r\n  const renderVideo = () => {\r\n    renderVideoToCanvas(videoRef, canvasRef, detectionFrameWidth, detectionFrameHeight, detectedPoints, debug);\r\n  };\r\n\r\n  const detectDocument = () => {\r\n    const largestPointsDetected = detectDocumentPoints(canvasRef);\r\n    if (largestPointsDetected?.length === 4) {\r\n      detectedPoints = largestPointsDetected;\r\n      const isValid = validatePoints(detectedPoints, guidancePoints);\r\n      // console.log(isValid);\r\n      if (isValid.isValid) {\r\n        setDocDetected(true);\r\n        setGuidanceMsg('capturing');\r\n      } else {\r\n        setDocDetected(false);\r\n        setGuidanceMsg(isValid.action ? isValid.action : 'Position document inside boundary');\r\n      }\r\n    } else {\r\n      noDetectionCounter+=1;\r\n    }\r\n    if (noDetectionCounter > 10) {\r\n      noDetectionCounter = 0;\r\n      detectedPoints = [];\r\n      setDocDetected(false);\r\n      setGuidanceMsg('Position document inside boundary');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n          ref={canvasWrapperRef}\r\n          style={{ position: 'relative' }}\r\n        >\r\n          {/* Video canvas */}\r\n          <canvas\r\n            id=\"canvasOutput\"\r\n            ref={canvasRef}\r\n            style={{ position: 'absolute' }}\r\n          ></canvas>\r\n\r\n          {/* Guidance frame + debug canvas */}\r\n          <canvas\r\n            id=\"canvasDebug\"\r\n            ref={canvasDebugRef}\r\n            style={{ position: 'absolute' }}\r\n          ></canvas>\r\n\r\n          <div\r\n            ref={guideRef}\r\n            id=\"guidance\"\r\n            style={{\r\n              position: 'absolute',\r\n              color: 'white',\r\n              textAlign: 'center',\r\n              bottom: '40px',\r\n              width: '100%',\r\n            }}\r\n          >\r\n            {guidanceMsg}\r\n          </div>\r\n          <div\r\n            ref={screenReaderRef}\r\n            role=\"alert\"\r\n            style={{\r\n              clipPath: 'inset(50%)',\r\n              height: '1px',\r\n              overflow: 'hidden',\r\n              position: 'absolute',\r\n              whiteSpace: 'nowrap',\r\n              width: '1px',\r\n            }}\r\n          >\r\n            {guidanceMsg}\r\n          </div>\r\n        </div>\r\n  );\r\n});\r\n\r\nexport default AutoCapture;\r\n","import React, { useRef, useState, useContext, createContext } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { isMobile } from 'react-device-detect';\r\n\r\nimport { CameraContext } from './CameraContext';\r\nimport AutoCapture from './AutoCapture';\r\n\r\nconst Camera = (props: any) => {\r\n\r\n  // console.log(props);\r\n\r\n  const [docDetected, setDocDetected] = useState(false);\r\n\r\n  let autocaptureProps = {};\r\n  if(props && props.autoCapture) {\r\n    autocaptureProps = props.autoCapture;\r\n  }\r\n\r\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const videoRef = React.useRef<Webcam>(null);\r\n  const AutoCaptureRef = useRef<any>(null);\r\n\r\n  const [videoWidth, setVideoWidth] = useState<number>(0);\r\n  const [videoHeight, setVideoHeight] = useState<number>(0);\r\n\r\n  const [guidanceWidth, setGuidanceWidth] = useState<number>(0);\r\n  const [guidanceHeight, setGuidanceHeight] = useState<number>(0);\r\n\r\n  const getVideoConstraints = () => {\r\n    let videoConstraints = {\r\n      facingMode: 'user',\r\n      width: { ideal: 1280 },\r\n      height: { ideal: 720 },\r\n    };\r\n    if (isMobile) {\r\n      videoConstraints = {\r\n        facingMode: 'environment',\r\n        width: { ideal: window.innerHeight },\r\n        height: { ideal: window.screen.width },\r\n      };\r\n    }\r\n    return videoConstraints;\r\n  };\r\n\r\n  const drawGuidanceFrame = () => {\r\n    const videoWidth = videoRef.current?.video?.videoWidth ? videoRef.current?.video?.videoWidth : 0;\r\n    const videoHeight = videoRef.current?.video?.videoHeight ? videoRef.current?.video?.videoHeight : 0;\r\n\r\n    const widthFactor = isMobile ? 1 : 2;\r\n\r\n    setGuidanceWidth(Math.round(videoWidth * (props.autoCapture.detectionFrameWidth / 100)) / widthFactor);\r\n    setGuidanceHeight(Math.round(videoHeight * (props.autoCapture.detectionFrameHeight / 100)));\r\n\r\n    //console.log(Math.round(videoWidth * (props.autoCapture.detectionFrameWidth / 100)) / widthFactor);\r\n    //console.log(videoHeight * (props.autoCapture.detectionFrameHeight / 100));\r\n  }\r\n\r\n  const videoStarted = () => {\r\n    // seems to have issues on ios without delay\r\n    setTimeout(() => {\r\n      if (AutoCaptureRef.current) {\r\n        setVideoWidth(videoRef.current?.video?.videoWidth ? videoRef.current?.video?.videoWidth : 0);\r\n        setVideoHeight(videoRef.current?.video?.videoHeight ? videoRef.current?.video?.videoHeight : 0);\r\n        drawGuidanceFrame();\r\n        AutoCaptureRef.current.videoStarted();\r\n      }\r\n    }, 2000);\r\n  };\r\n\r\n  const videoConstraints = getVideoConstraints();\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ position: 'relative' }}>\r\n        \r\n        {/* react webcam component */}\r\n        <div ref={videoWrapperRef}>\r\n          <Webcam\r\n            videoConstraints={videoConstraints}\r\n            ref={videoRef}\r\n            style={{ position: 'absolute' }}\r\n            onUserMedia={videoStarted}\r\n          />\r\n        </div>\r\n        {/* guidance frame */}\r\n        <div style={{ position: 'absolute', zIndex: 2, width: videoWidth, height: videoHeight }}>\r\n          { guidanceWidth && guidanceHeight ?\r\n          <svg width={videoWidth} height={videoHeight} xmlns=\"http://www.w3.org/2000/svg\">\r\n            <defs>\r\n              <mask id=\"mask1\">\r\n                <rect mask=\"url(#mask1)\" width={videoWidth} height={videoHeight} x=\"0\" y=\"0\" style={{ fill: 'white', stroke:'none', strokeWidth:5, opacity:0.5 }} />\r\n                <rect width={guidanceWidth} height={guidanceHeight} x={videoWidth / 2 - guidanceWidth / 2} y={videoHeight / 2 - guidanceHeight / 2} rx=\"20\" ry=\"20\" />\r\n              </mask>\r\n            </defs>\r\n            <rect mask=\"url(#mask1)\" width={videoWidth} height={videoHeight} x=\"0\" y=\"0\" style={{ fill: 'white', stroke:'none', strokeWidth:5, opacity:0.5 }} />\r\n            <rect width={guidanceWidth} height={guidanceHeight} x={videoWidth / 2 - guidanceWidth / 2} y={videoHeight / 2 - guidanceHeight / 2} rx=\"20\" ry=\"20\" style={{ fill: 'none', stroke:docDetected ? 'green' : 'black', strokeWidth:5, opacity:1 }} />\r\n          </svg>\r\n           : null }\r\n        </div>\r\n        {/* auto capture */}\r\n        <div style={{ position: 'absolute', zIndex: 1 }}>\r\n        <CameraContext.Provider value={{docDetected, setDocDetected}}>\r\n          <AutoCapture {...autocaptureProps} ref={AutoCaptureRef} videoRef={videoRef} />\r\n        </CameraContext.Provider>\r\n        </div>\r\n\r\n      </div>\r\n\r\n      <div style={{ position: 'relative', zIndex: 3 }}>\r\n        <a href=\"/camster\">Back to settings</a>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Camera;\r\n"],"names":["CameraContext","createContext","findBiggestContour","contoursVec","minAreaThreshold","maxArea","largestContour","i","size","contour","get","area","cv","delete","peri","approx","isQuadrilateral","rows","getCornerPoints","_topLeftPoint","_topLeftPoint2","_topRightPoint","_topRightPoint2","_bottomRightPoint","_bottomRightPoint2","_bottomLeftPoint","_bottomLeftPoint2","points","center","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","data32S","length","point","x","y","distance","Math","hypot","push","calculatePointLineDistance","lineStart","lineEnd","sqrt","validatePoints","detectedPoints","guidancePoints","distances","calculatePointLineDistances","lastDetectedPoints","width","every","num","isValid","action","some","margin","guidanceBounds","getBounds","detectedBounds","minX","maxX","minY","maxY","min","map","max","UniqueNameSet","Set","constructor","values","super","names","value","this","includes","name","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","forEach","task","requestAnimationFrame","registerTask","add","toString","unregisterTask","cancelAnimationFrame","forwardRef","_ref","ref","debug","detectionFrameWidth","detectionFrameHeight","videoRef","docDetected","setDocDetected","useContext","canvas","noDetectionCounter","guidanceMsg","setGuidanceMsg","useState","canvasWrapperRef","React","canvasRef","useRef","canvasDebugRef","guideRef","screenReaderRef","useImperativeHandle","videoStarted","initialiseCanvas","renderVideo","detectDocument","setupCanvasSize","_videoRef$current","video","current","videoWidth","height","videoHeight","canvasWrapper","style","getGuidancePoints","boxWidth","round","boxHeight","widthFactor","isMobile","heightFactor","topLeft","topRight","bottomLeft","renderVideoToCanvas","_videoRef$current2","canv","getCanvas","getContext","willReadFrequently","drawImage","img","red","largestPointsDetected","src","kernelSize","floor","cols","meanIntensity","intensityThresholds","morphKernel","hierarchy","largestContourPoints","detectDocumentPoints","_jsxs","position","children","_jsx","id","color","textAlign","bottom","role","clipPath","overflow","whiteSpace","props","autocaptureProps","autoCapture","videoWrapperRef","AutoCaptureRef","setVideoWidth","setVideoHeight","guidanceWidth","setGuidanceWidth","guidanceHeight","setGuidanceHeight","videoConstraints","getVideoConstraints","facingMode","ideal","window","innerHeight","screen","Webcam","onUserMedia","setTimeout","_videoRef$current5","_videoRef$current5$vi","_videoRef$current6","_videoRef$current6$vi","_videoRef$current7","_videoRef$current7$vi","_videoRef$current8","_videoRef$current8$vi","drawGuidanceFrame","_videoRef$current$vid","_videoRef$current2$vi","_videoRef$current3","_videoRef$current3$vi","_videoRef$current4","_videoRef$current4$vi","zIndex","xmlns","mask","fill","stroke","strokeWidth","opacity","rx","ry","Provider","AutoCapture","href"],"sourceRoot":""}