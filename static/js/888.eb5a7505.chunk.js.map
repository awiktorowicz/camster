{"version":3,"file":"static/js/888.eb5a7505.chunk.js","mappings":"0KAAA,MAAMA,UAAsBC,IACxBC,WAAAA,CAAYC,GACRC,MAAMD,GAEN,MAAME,EAAa,GACnB,IAAK,IAAIC,KAASC,KACVF,EAAMG,SAASF,EAAMG,MACrBF,KAAKG,OAAOJ,GAEZD,EAAMM,KAAKL,EAAMG,KAG7B,EA2CK,MAAMG,EAAmB,IAxClC,MAAuBV,WAAAA,GAAA,KACXW,MAAa,IAAIb,EAAc,IAAI,KACnCc,IAAc,GAAI,KAClBC,cAAwBC,YAAYC,MAAM,KAC1CC,YAA6B,KAAM,KAEnCC,IAAOC,IACKA,EAAcb,KAAKQ,cAGrB,IAAOR,KAAKO,MAC1BP,KAAKM,MAAMQ,SAASC,IACMF,EAAcE,EAAKP,cACrB,IAAOO,EAAKR,MAC5BQ,EAAKA,KAAKF,GACVE,EAAKP,cAAgBK,EACzB,IAEJb,KAAKQ,cAAgBK,GAGvBb,KAAKW,YAAcK,sBAAsBhB,KAAKY,IAAI,CAClD,CAEKK,YAAAA,CAAaF,EAA4BR,GAC9CP,KAAKM,MAAMY,IAAI,CAACH,OAAMR,MAAKL,KAAMa,EAAKI,WAAYX,cAAe,IACzC,IAApBR,KAAKM,MAAMc,OACbpB,KAAKW,YAAcK,sBAAsBhB,KAAKY,KAElD,CAEOS,cAAAA,CAAeN,GACpBf,KAAKM,MAAMH,OAAOY,GACM,IAApBf,KAAKM,MAAMc,MAAmC,OAArBpB,KAAKW,cAChCW,qBAAqBtB,KAAKW,aAC1BX,KAAKW,YAAc,KAEvB,G,+BChDG,MA4DDY,EAAmBA,CAACC,EAAeC,KACvC,IAAIC,EAAU,IAAIC,IAAAA,WACdC,EAAaD,IAAAA,aACfF,EAAOI,OACP,EACAF,IAAAA,SACAF,EAAOK,SAASC,GAAM,CAACA,EAAEC,EAAGD,EAAEE,MAGhCP,EAAQQ,UAAUN,GAElB,MACMO,EAAQ,IAAIR,IAAAA,QAAU,IAAK,EAAG,EAAG,KAGvCA,IAAAA,UAAaH,EAAOE,GAJH,EAIsBS,EAFrB,GAIlBP,EAAWzB,SACXuB,EAAQvB,QAAQ,EAoCZiC,EAAmBV,GAChBA,GAA4B,IAAjBA,EAAQW,KAGtBC,EAAqBA,CACzBC,EACAC,KAEA,IAAIC,EAAU,IACVC,EAAiB,KAErB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAYnB,SAAUuB,EAAG,CAC3C,IAAIjB,EAAUa,EAAYK,IAAID,GAC1BE,EAAOlB,IAAAA,YAAeD,GAE1B,GAAImB,EAAOL,EAAkB,CAC3Bd,EAAQvB,SACR,QACF,CAEA,IAAI2C,EAAOnB,IAAAA,UAAaD,GAAS,GAC7BqB,EAAS,IAAIpB,IAAAA,KACjBA,IAAAA,aAAgBD,EAASqB,EAAQ,IAAOD,GAAM,GAE1CD,EAAOJ,GAAWL,EAAgBW,IAChCL,GAAgBA,EAAevC,SACnCuC,EAAiBK,EACjBN,EAAUI,GAEVE,EAAO5C,SAGTuB,EAAQvB,QACV,CAEA,OAAOuC,CAAc,EAIjBM,EAAkB,SAACC,GAA6C,IAA7BC,EAAcC,UAAAtB,OAAA,QAAAuB,IAAAD,UAAA,GAAAA,UAAA,GAAGF,EAExDtB,IAAAA,SAAYsB,EAAQC,EAAQvB,IAAAA,gBAG5B,IAAI0B,EAAaC,KAAKC,IACpB,EACAD,KAAKE,MAAMF,KAAKG,IAAIR,EAAOZ,KAAMY,EAAOS,MAAQ,MAElD/B,IAAAA,aAAgBsB,EAAQC,EAAQ,IAAIvB,IAAAA,MAAQ0B,EAAYA,GAAa,EAAG,GAGxE,IAAIM,EAAsBC,EAA6BX,GACvDtB,IAAAA,MAASsB,EAAQC,EAAQS,EAAoB,GAAIA,EAAoB,IAGrE,IAAIE,EAAclC,IAAAA,sBAChBA,IAAAA,cACA,IAAIA,IAAAA,MAAQ,EAAG,IAEjBA,IAAAA,aAAgBsB,EAAQC,EAAQvB,IAAAA,YAAgBkC,EAClD,EAGMD,EAA+B,SACnCE,GAGI,IAFJC,EAAmBZ,UAAAtB,OAAA,QAAAuB,IAAAD,UAAA,GAAAA,UAAA,GAAG,IACtBa,EAAmBb,UAAAtB,OAAA,QAAAuB,IAAAD,UAAA,GAAAA,UAAA,GAAG,KAElBc,EAAgBtC,IAAAA,KAAQmC,GAAQ,GAIpC,MAAO,CAHcC,EAAcE,EACdD,EAAcC,EAGrC,EAEaC,EAAmBxC,IAAkB,IAADyC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAC/C,IAAKhD,EAAS,OAAO,KAErB,IAAID,EAAqB,GAEvB,MAAMkD,EADKhD,IAAAA,YAAeD,GACNiD,OAEpB,IAAIC,EAGAC,EAGAC,EAGAC,EARAC,EAAkB,EAGlBC,EAAmB,EAGnBC,EAAqB,EAGrBC,EAAsB,EAE1B,IAAK,IAAIxC,EAAI,EAAGA,EAAIjB,EAAQ0D,QAAQvD,OAAQc,GAAK,EAAG,CAChD,MAAM0C,EAAQ,CAAErD,EAAGN,EAAQ0D,QAAQzC,GAAIV,EAAGP,EAAQ0D,QAAQzC,EAAI,IACxD2C,EAAWhC,KAAKiC,MAAMF,EAAMrD,EAAI2C,EAAO3C,EAAGqD,EAAMpD,EAAI0C,EAAO1C,GAC7DoD,EAAMrD,EAAI2C,EAAO3C,GAAKqD,EAAMpD,EAAI0C,EAAO1C,EACvCqD,EAAWN,IACXJ,EAAeS,EACfL,EAAkBM,GAEXD,EAAMrD,EAAI2C,EAAO3C,GAAKqD,EAAMpD,EAAI0C,EAAO1C,EAC9CqD,EAAWL,IACXJ,EAAgBQ,EAChBJ,EAAmBK,GAEZD,EAAMrD,EAAI2C,EAAO3C,GAAKqD,EAAMpD,EAAI0C,EAAO1C,EAC9CqD,EAAWJ,IACXJ,EAAkBO,EAClBH,EAAqBI,GAEdD,EAAMrD,EAAI2C,EAAO3C,GAAKqD,EAAMpD,EAAI0C,EAAO1C,GAC9CqD,EAAWH,IACXJ,EAAmBM,EACnBF,EAAsBG,EAG9B,CAMF,OAJA7D,EAAOrB,KAAK,IAAIuB,IAAAA,OAAqB,QAAbwC,EAACS,SAAY,IAAAT,OAAA,EAAZA,EAAcnC,EAAe,QAAdoC,EAAEQ,SAAY,IAAAR,OAAA,EAAZA,EAAcnC,IACxDR,EAAOrB,KAAK,IAAIuB,IAAAA,OAAsB,QAAd0C,EAACQ,SAAa,IAAAR,OAAA,EAAbA,EAAerC,EAAgB,QAAfsC,EAAEO,SAAa,IAAAP,OAAA,EAAbA,EAAerC,IAC1DR,EAAOrB,KAAK,IAAIuB,IAAAA,OAAyB,QAAjB4C,EAACQ,SAAgB,IAAAR,OAAA,EAAhBA,EAAkBvC,EAAmB,QAAlBwC,EAAEO,SAAgB,IAAAP,OAAA,EAAhBA,EAAkBvC,IAChER,EAAOrB,KAAK,IAAIuB,IAAAA,OAAwB,QAAhB8C,EAACK,SAAe,IAAAL,OAAA,EAAfA,EAAiBzC,EAAkB,QAAjB0C,EAAEI,SAAe,IAAAJ,OAAA,EAAfA,EAAiBzC,IACvDR,CAAM,EAGT+D,EAAoBA,CAACC,EAAaC,EAAeC,KACrD,MAAMC,EAAWtC,KAAKuC,MAAMH,GAASD,EAAOK,cAAgB,MACtDC,EAAYzC,KAAKuC,MAAMF,GAAUF,EAAOO,eAAiB,MAEzDC,EAAcC,EAAAA,GAAWN,EAAW,EAAIA,EAAW,EAEnDO,EAAeJ,EAAY,EAE3BK,EAAU,IAAIzE,IAAAA,OAClB+D,EAAQ,EAAIO,EACZN,EAAS,EAAIQ,GAETE,EAAW,IAAI1E,IAAAA,OACnB+D,EAAQ,EAAIO,EACZN,EAAS,EAAIQ,GAETG,EAAa,IAAI3E,IAAAA,OACrB+D,EAAQ,EAAIO,EACZN,EAAS,EAAIQ,GAOf,MAAO,CAACC,EAASC,EALG,IAAI1E,IAAAA,OACtB+D,EAAQ,EAAIO,EACZN,EAAS,EAAIQ,GAGyBG,EAAW,EAG/CC,EAAoBA,CAACzC,EAAgBrC,KAEzCE,IAAAA,UAAamC,EAAQrC,EAAO,GAAIA,EAAO,GADzB,CAAC,IAAK,IAAK,IAAK,KACoB,EAAE,ECjRtD,IAAI+E,EAAQ,EAEL,MAoFDC,EAAoBA,CACxBC,EACAC,EACAC,EACAC,KAEA,IAAInB,EAAQiB,EAAe,GAAG3E,EAAI2E,EAAe,GAAG3E,EAEpD,GAAI0E,EAAUI,OAAOC,GAAQA,EAAM,IAEjC,OADAF,EAAgBG,UAAY,aACrB,EAGT,GAAIN,EAAUI,OAAOC,GAAQA,GAAO,IAAI,CACtC,GAAIL,EAAUO,MAAM3B,GAAaA,EAAWI,EAAQkB,EAAS,MAE3D,OADAC,EAAgBG,UAAY,YACrB,EAETH,EAAgBG,UAAY,EAC9B,CAEA,OAAO,CAAI,EAGPE,EAA8BA,CAClCC,EACAR,KAEA,IAAID,EAAY,GAkChB,OAhCAA,EAAUtG,KACRgH,EACED,EAAmB,GACnBR,EAAe,GACfA,EAAe,KAInBD,EAAUtG,MACPgH,EACCD,EAAmB,GACnBR,EAAe,GACfA,EAAe,KAInBD,EAAUtG,MACPgH,EACCD,EAAmB,GACnBR,EAAe,GACfA,EAAe,KAInBD,EAAUtG,KACRgH,EACED,EAAmB,GACnBR,EAAe,GACfA,EAAe,KAIZD,CAAS,EAGZU,EAA6BA,CACjC/B,EACAgC,EACAC,MAIGA,EAAQrF,EAAIoF,EAAUpF,GAAKoD,EAAMrD,GACjCsF,EAAQtF,EAAIqF,EAAUrF,GAAKqD,EAAMpD,EAClCqF,EAAQtF,EAAIqF,EAAUpF,EACtBqF,EAAQrF,EAAIoF,EAAUrF,GACNsB,KAAKiE,MACpBD,EAAQrF,EAAIoF,EAAUpF,IAAM,GAAKqF,EAAQtF,EAAIqF,EAAUrF,IAAM,GAM5DwF,EAAeA,CACnBC,EACAC,EACAb,KAEA,IAAIc,EAAU,GAAMF,EAYpB,OAVIC,EAAeC,IACjBd,EAAgBG,UAAY,WAC5BY,QAAQC,IAAI,aAGVH,EAAeD,IACjBZ,EAAgBG,UAAY,WAC5BY,QAAQC,IAAI,aAGVF,GAAWD,GAAgBA,GAAgBD,IAC7CZ,EAAgBG,UAAY,iBAC5BY,QAAQC,IAAI,mBAEL,EAEG,EAGRC,EAAmBA,CACvBnB,EACAoB,EACAlB,KAEA,MAAMmB,EAAiBC,EAAUtB,GAC3BuB,EAAiBD,EAAUF,GAEjC,OAAIG,EAAeC,KAAOH,EAAeG,MACvCtB,EAAgBG,UAAY,YAC5BY,QAAQC,IAAI,cACL,GAGLK,EAAeE,KAAOJ,EAAeI,MACvCvB,EAAgBG,UAAY,aAC5BY,QAAQC,IAAI,eACL,GAILK,EAAeG,KAAOL,EAAeK,MACvCxB,EAAgBG,UAAY,UAC5BY,QAAQC,IAAI,YACL,KAGLK,EAAeI,KAAON,EAAeM,QACvCzB,EAAgBG,UAAY,YAC5BY,QAAQC,IAAI,cACL,EAGE,EAGPI,EAAaxG,IAMV,CAAE0G,KALI7E,KAAKG,OAAOhC,EAAO8G,KAAKlD,GAAUA,EAAMrD,KAKtCoG,KAJF9E,KAAKC,OAAO9B,EAAO8G,KAAKlD,GAAUA,EAAMrD,KAIhCqG,KAHR/E,KAAKG,OAAOhC,EAAO8G,KAAKlD,GAAUA,EAAMpD,KAG1BqG,KAFdhF,KAAKC,OAAO9B,EAAO8G,KAAKlD,GAAUA,EAAMpD,O,aCjOvD,MA6GA,EA7GgBwD,IACd,MAAO+C,EAAYC,IAAiBC,EAAAA,EAAAA,MAE9BC,EAAkBC,EAAAA,OAAoC,MACtDC,EAAmBD,EAAAA,OAAoC,MACvDE,EAAWF,EAAAA,OAAqB,MAChCG,GAAYC,EAAAA,EAAAA,QAAiC,MAC7CC,EAAWL,EAAAA,OAAoC,MAC/CM,EAAkBN,EAAAA,OAAoC,MAEtDO,EFlB2BC,MAC/B,IAAID,EAAmB,CACnBE,WAAY,CAAEC,MAAO,QACrB5D,MAAO,CAAE6D,MAAO,MAChB5D,OAAQ,CAAE4D,MAAO,MASrB,OAPGrD,EAAAA,KACCiD,EAAmB,CACjBE,WAAY,CAAEC,MAAO,eACrB5D,MAAO,CAAE6D,MAAOC,OAAOC,aACvB9D,OAAQ,CAAE4D,MAAOC,OAAOE,OAAOhE,SAG9ByD,CAAgB,EEKAC,GAEnBO,EAAmBA,KFJIC,EAC7Bd,EACAC,EACAF,EACApD,EACAoE,KACI,IAADC,EACD,MAAMC,EAAgB,OAARjB,QAAQ,IAARA,GAAiB,QAATgB,EAARhB,EAAUkB,eAAO,IAAAF,OAAT,EAARA,EAAmBC,MAC3BjG,EAASiF,EAAUiB,QACzBlG,EAAO4B,MAAQqE,EAAME,WACrBnG,EAAO6B,OAASoE,EAAMG,YACtB,MAAMC,EAAgBtB,EAAiBmB,QACvCG,EAAcC,MAAM1E,MAAQ,GAAGqE,EAAME,eACrCE,EAAcC,MAAMzE,OAAS,GAAGoE,EAAMG,gBAExCL,EAAqBrE,EAAkBC,EAAQ3B,EAAO4B,MAAO5B,EAAO6B,QAAQ,EEV1EiE,CACEd,EACAC,EACAF,EACApD,EACAoE,EACD,EAGGQ,EAAcA,KFIaC,EACjCxB,EACAC,EACAtD,EACAkB,EACAQ,KACI,IAADoD,EACD,MAAMC,EAAe,OAAR1B,QAAQ,IAARA,GAAiB,QAATyB,EAARzB,EAAUkB,eAAO,IAAAO,OAAT,EAARA,EAAmBE,YAChC,GAAID,EAAM,CACSzB,EAAUiB,QACNU,WAAW,KAAM,CAAEC,oBAAoB,IACtDC,UAAU9B,EAASkB,QAAQD,MAAO,EAAG,EAAGS,EAAK9E,MAAO8E,EAAK7E,QAE7D,MAAMkF,EAAMlJ,IAAAA,OAAUoH,EAAUiB,SAEpCzD,EAAkBsE,EAAKlE,GAEfQ,GAAsB1B,EAAOqF,OACnCvJ,EAAiBsJ,EAAK1D,GAGpBxF,IAAAA,OAAUoH,EAAUiB,QAASa,GAC7BA,EAAI1K,QACR,GE1BAmK,CACExB,EACAC,EACAtD,EACA+C,EAAWuC,YAAYpE,eACvB6B,EAAWuC,YAAY5D,mBACxB,EAGG6D,EAAeA,KFyCOC,EAACnC,EAAeC,EAAgBtD,EAAayF,KAA8B,IAADC,EACpG,MAAMpB,EAAgB,OAARjB,QAAQ,IAARA,GAAiB,QAATqC,EAARrC,EAAUkB,eAAO,IAAAmB,OAAT,EAARA,EAAmBpB,MAEjCA,EAAMpE,OAASoE,EAAMG,YACrBH,EAAMrE,MAAQqE,EAAME,WACpB,MAAMmB,EAAM,IAAIzJ,IAAAA,cAAgBoI,GAC1BsB,EAAM,IAAI1J,IAAAA,KAAOoI,EAAMpE,OAAQoE,EAAMrE,MAAO/D,IAAAA,SAClDyJ,EAAIE,KAAKD,GAEXrI,EAAgBqI,GAEhB,IAAI9I,EAAc,IAAIZ,IAAAA,WAChB4J,EAAY,IAAI5J,IAAAA,KACpBA,IAAAA,aACA0J,EACA9I,EACEgJ,EACF5J,IAAAA,cACAA,IAAAA,qBAGF,MAAMgG,EAAYoC,EAAMpE,OAAS,EAAKoE,EAAMrE,MAAS,EAErD,IAAIhD,EAAiBJ,EAAmBC,EAAaoF,GAGrDuD,EAF2BhH,EAAgBxB,IAI3C2I,EAAIlL,SACJoL,EAAUpL,SACVoC,EAAYpC,QAAQ,EEtElB8K,CAAenC,EAAUC,EAAWtD,EAAQyF,EAAoB,EAG5DM,EAAeA,KD5CQC,EAC7B9E,EACAQ,EACAuE,EACAC,EACAC,EACAC,EACA5C,EACA6C,EACAC,KAEA,MAAMlF,EAAkBoC,EAASe,QACjC,IAAK7C,EAAoB,OAEzB,MAAM6E,EAAoBrK,IAAAA,aACxBgF,EAAe9E,OACf,EACAF,IAAAA,SACAgF,EAAe7E,SAASC,GAAM,CAACA,EAAEC,EAAGD,EAAEE,MAGlCgK,EAAoBtK,IAAAA,aACxBwF,EAAmBtF,OACnB,EACAF,IAAAA,SACAwF,EAAmBrF,SAASC,GAAM,CAACA,EAAEC,EAAGD,EAAEE,MAG5C,GAAsB,SAAlB6J,EAA0B,CAC5B,MAAMrE,EAAe9F,IAAAA,YAAeqK,GAC9BtE,EAAe/F,IAAAA,YAAesK,GAKpC,GAHAL,EACEpE,EAAaC,EAAcC,EAAcb,KAEtC6E,EAEH,YADAlF,EAAQ,EAGZ,MAAO,GAAsB,UAAlBsF,EAA2B,CACpC,IAAIpF,EAAYQ,EACdC,EACAR,GAWF,GARAiF,EACEnF,EACEC,EACAC,EACAoF,EACAlF,KAGC6E,EAEH,YADAlF,EAAQ,EAGZ,CAEAqF,EACE/D,EAAiBnB,EAAgBQ,EAAoBN,IAElD8E,GAKDD,GAAeC,IACjB9E,EAAgBG,UAAY,iCAC5BY,QAAQC,IAAI,kCACZD,QAAQC,IAAIrB,GACZA,KAGY,IAAVA,IACFK,EAAgBG,UAAY,UAC5BY,QAAQC,IAAI,WACZrB,EAAQ,GAGVwF,EAAkB7L,SAClB8L,EAAkB9L,UAlBhBqG,EAAQ,CAkBgB,ECpCxBiF,CACEjD,EAAWuC,YAAYpE,eACvB6B,EAAWuC,YAAY5D,mBACvBqB,EAAWuC,YAAYW,YACvBlD,EAAWuC,YAAYY,gBACvBC,EACAC,EACA5C,EACAxD,EAAOqG,cACPrG,EAAOsG,gBACR,EAGGb,EAAuBzJ,IAC3B,MAAMyK,EAAmB1D,EACzB0D,EAAiBnB,YAAY5D,mBAAqB1F,EAClDgH,EAAcyD,EAAiB,EAG3BrC,EAAwBpI,IAC5B,MAAMyK,EAAmB1D,EACzB0D,EAAiBnB,YAAYpE,eAAiBlF,EAC9CgH,EAAcyD,EAAiB,EAG3BN,EAAqBO,IACzB,MAAMD,EAAmB1D,EACzB0D,EAAiBnB,YAAYW,YAAcS,EAC3C1D,EAAcyD,EAAiB,EAG3BL,EAAyBM,IAC7B,MAAMD,EAAmB1D,EACzB0D,EAAiBnB,YAAYY,gBAAkBQ,EAC/C1D,EAAcyD,EAAiB,EAG3BE,EAAkBA,KAAO,IAADC,EAAAC,EAC5B,MAAMC,EAA4B,QAAnBF,EAAGpD,EAASe,eAAO,IAAAqC,OAAA,EAAhBA,EAAkBrF,WACY,QAA1BsF,EAAGpD,EAAgBc,eAAO,IAAAsC,OAAA,EAAvBA,EAAyBtF,aAEzBuF,GAAarD,EAAgBc,SAAWf,EAASe,UACxEd,EAAgBc,SAAWuC,EAAYrD,EAAgBc,QAAQhD,UAAYuF,EAAYrD,EAAgBc,QAAQhD,UAAY,GAC7H,EAcF,OACEwF,EAAAA,EAAAA,MAAA,OAAAC,SAAA,EACED,EAAAA,EAAAA,MAAA,OAAKpC,MAAO,CAACsC,SAAU,YAAYD,SAAA,EACjCE,EAAAA,EAAAA,KAAA,OAAKC,IAAKjE,EAAgB8D,UAACE,EAAAA,EAAAA,KAACE,IAAM,CAAC1D,iBAAkBA,EAAkByD,IAAK9D,EAAUgE,YAdvEC,KAEnBC,YAAW,KACTrD,IACAtJ,EAAiBY,aAAaoJ,EAAa,IAC3ChK,EAAiBY,aAAa+J,EAAc,IAC5C3K,EAAiBY,aAAauK,EAAc,GAC5CnL,EAAiBY,aAAamL,EAAiB,GAAG,GACjD,IAAK,EAM6GhC,MAAO,CAACsC,SAAU,iBACnIF,EAAAA,EAAAA,MAAA,OAAKI,IAAK/D,EAAkBuB,MAAO,CAACsC,SAAU,YAAYD,SAAA,EACxDE,EAAAA,EAAAA,KAAA,UAAQM,GAAG,eAAeL,IAAK7D,EAAWqB,MAAO,CAACsC,SAAU,eAC5DC,EAAAA,EAAAA,KAAA,OAAKC,IAAK3D,EAAUgE,GAAG,WAAW7C,MAAO,CAACsC,SAAU,WAAYvK,MAAO,QAAS+K,UAAW,SAAUC,OAAQ,OAAQzH,MAAO,QAAQ+G,SAAC,uCACrIE,EAAAA,EAAAA,KAAA,OAAKC,IAAK1D,EAAiBkE,KAAK,QAAQhD,MAAO,CAACiD,SAAU,aAAc1H,OAAQ,MAAO2H,SAAU,SAAUZ,SAAU,WAAYa,WAAY,SAAU7H,MAAO,OAAO+G,SAAC,6CAG1KE,EAAAA,EAAAA,KAAA,OAAKvC,MAAO,CAACsC,SAAU,YAAYD,UAACE,EAAAA,EAAAA,KAAA,KAAGa,KAAK,WAAUf,SAAC,yBACnD,C","sources":["camera/AnimationManger.ts","camera/CameraUtils.ts","camera/CaptureDocument.ts","camera/Camera.tsx"],"sourcesContent":["class UniqueNameSet extends Set {\r\n    constructor(values: any) {\r\n        super(values);\r\n\r\n        const names: any = [];\r\n        for (let value of this) {\r\n            if (names.includes(value.name)) {\r\n                this.delete(value);\r\n            } else {\r\n                names.push(value.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass AnimationManager {\r\n    private tasks: any = new UniqueNameSet([]);\r\n    private fps: number = 60; // Target FPS\r\n    private lastFrameTime: number = performance.now();\r\n    private animationId: number | null = null; // Store the animation frame ID\r\n  \r\n    private run = (currentTime: number) => {\r\n      const deltaTime = currentTime - this.lastFrameTime;\r\n  \r\n      // Ensure the tasks only run if enough time has passed to meet the target FPS\r\n      if (deltaTime > 1000 / this.fps) {\r\n        this.tasks.forEach((task: any) => {\r\n            const taskDeltaTime = currentTime - task.lastFrameTime;\r\n            if (taskDeltaTime > 1000 / task.fps) {\r\n                task.task(currentTime);\r\n                task.lastFrameTime = currentTime;\r\n            }\r\n        });\r\n        this.lastFrameTime = currentTime;\r\n      }\r\n  \r\n      this.animationId = requestAnimationFrame(this.run);\r\n    };\r\n  \r\n    public registerTask(task: FrameRequestCallback, fps: number) {\r\n      this.tasks.add({task, fps, name: task.toString(), lastFrameTime: 0});\r\n      if (this.tasks.size === 1) {\r\n        this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\r\n      }\r\n    }\r\n  \r\n    public unregisterTask(task: FrameRequestCallback) {\r\n      this.tasks.delete(task);\r\n      if (this.tasks.size === 0 && this.animationId !== null) {\r\n        cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\r\n        this.animationId = null; // Reset the ID\r\n      }\r\n    }\r\n  }\r\n  \r\n  export const animationManager = new AnimationManager();","import React from \"react\";\r\nimport { isMobile } from 'react-device-detect';\r\nimport cv from \"@techstark/opencv-js\";\r\n\r\nexport const getVideoConstraints = () => {\r\n    let videoConstraints = {\r\n        facingMode: { exact: \"user\" },\r\n        width: { ideal: 1280 },\r\n        height: { ideal: 720 }\r\n    };\r\n    if(isMobile) {\r\n        videoConstraints = {\r\n          facingMode: { exact: \"environment\" },\r\n          width: { ideal: window.innerHeight },\r\n          height: { ideal: window.screen.width } \r\n        };\r\n      }\r\n    return videoConstraints;\r\n}\r\n\r\nexport const setupCanvasSize = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  canvasWrapperRef: any,\r\n  config: any,\r\n  updateGuidancePoints: any,\r\n) => {\r\n    const video = videoRef?.current?.video;\r\n    const canvas = canvasRef.current;\r\n    canvas.width = video.videoWidth;\r\n    canvas.height = video.videoHeight;\r\n    const canvasWrapper = canvasWrapperRef.current;\r\n    canvasWrapper.style.width = `${video.videoWidth}px`;\r\n    canvasWrapper.style.height = `${video.videoHeight}px`;\r\n\r\n  updateGuidancePoints(getGuidancePoints(config, canvas.width, canvas.height));\r\n};\r\n\r\nexport const renderVideoToCanvas = (\r\n  videoRef: any,\r\n  canvasRef: any,\r\n  config: any,\r\n  guidancePoints: cv.Point[],\r\n  lastDetectedPoints: cv.Point[],\r\n) => {\r\n    const canv = videoRef?.current?.getCanvas();\r\n    if (canv) {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n        ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\r\n\r\n        const img = cv.imread(canvasRef.current);\r\n\r\n    drawGuidanceFrame(img, guidancePoints);\r\n\r\n        if (lastDetectedPoints && config.debug) {\r\n      drawDebugContour(img, lastDetectedPoints);\r\n        }\r\n\r\n        cv.imshow(canvasRef.current, img);\r\n        img.delete();\r\n    }\r\n};\r\n\r\nconst drawDebugContour = (input: cv.Mat, points: cv.Point[]) => {\r\n  let contour = new cv.MatVector();\r\n  let pointArray = cv.matFromArray(\r\n    points.length,\r\n    1,\r\n    cv.CV_32SC2,\r\n    points.flatMap((p) => [p.x, p.y]),\r\n  );\r\n\r\n  contour.push_back(pointArray);\r\n\r\n  const isClosed = true;\r\n  const color = new cv.Scalar(255, 0, 0, 255);\r\n  const thickness = 2;\r\n\r\n  cv.polylines(input, contour, isClosed, color, thickness);\r\n\r\n  pointArray.delete();\r\n  contour.delete();\r\n};\r\n\r\nexport const detectDocument = (videoRef: any, canvasRef: any, config: any, updatePointDetected: any) => {\r\n    const video = videoRef?.current?.video;\r\n    // fixes bug https://github.com/opencv/opencv/issues/19922\r\n    video.height = video.videoHeight;\r\n    video.width = video.videoWidth;\r\n    const cap = new cv.VideoCapture(video);\r\n    const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\r\n    cap.read(src);\r\n\r\n  preprocessImage(src);\r\n\r\n  let contoursVec = new cv.MatVector();\r\n    let hierarchy = new cv.Mat();\r\n    cv.findContours(\r\n    src,\r\n    contoursVec,\r\n      hierarchy,\r\n    cv.RETR_EXTERNAL,\r\n    cv.CHAIN_APPROX_SIMPLE,\r\n  );\r\n\r\n  const minArea = ((video.height / 2) * video.width) / 8;\r\n  // const minArea = 5000;\r\n  let largestContour = findBiggestContour(contoursVec, minArea);\r\n  let largestContourPoints = getCornerPoints(largestContour);\r\n\r\n  updatePointDetected(largestContourPoints);\r\n\r\n  src.delete();\r\n  hierarchy.delete();\r\n  contoursVec.delete();\r\n};\r\n\r\nconst isQuadrilateral = (contour: cv.Mat | null) => {\r\n  return contour && contour.rows === 4;\r\n};\r\n\r\nconst findBiggestContour = (\r\n  contoursVec: cv.MatVector,\r\n  minAreaThreshold: number,\r\n) => {\r\n  let maxArea = 1000;\r\n  let largestContour = null;\r\n\r\n  for (let i = 0; i < contoursVec.size(); ++i) {\r\n    let contour = contoursVec.get(i);\r\n    let area = cv.contourArea(contour);\r\n\r\n    if (area < minAreaThreshold) {\r\n      contour.delete();\r\n      continue;\r\n    }\r\n\r\n    let peri = cv.arcLength(contour, true);\r\n    let approx = new cv.Mat();\r\n    cv.approxPolyDP(contour, approx, 0.02 * peri, true);\r\n\r\n    if (area > maxArea && isQuadrilateral(approx)) {\r\n      if (largestContour) largestContour.delete();\r\n      largestContour = approx;\r\n      maxArea = area;\r\n    } else {\r\n      approx.delete();\r\n    }\r\n\r\n    contour.delete();\r\n  }\r\n\r\n  return largestContour;\r\n};\r\n\r\n// Note the source is passed by ref\r\nconst preprocessImage = (source: cv.Mat, output: cv.Mat = source) => {\r\n  // Convert to grayscale\r\n  cv.cvtColor(source, output, cv.COLOR_RGB2GRAY);\r\n\r\n  // Apply gaussian blur\r\n  let kernelSize = Math.max(\r\n    3,\r\n    Math.floor(Math.min(source.rows, source.cols) / 100),\r\n  );\r\n  cv.GaussianBlur(source, output, new cv.Size(kernelSize, kernelSize), 0, 0);\r\n\r\n  // Apply canny edge\r\n  let intensityThresholds = calculateIntensityThresholds(source);\r\n  cv.Canny(source, output, intensityThresholds[0], intensityThresholds[1]);\r\n\r\n  // Apply morphology closing\r\n  let morphKernel = cv.getStructuringElement(\r\n    cv.MORPH_ELLIPSE,\r\n    new cv.Size(5, 5),\r\n  );\r\n  cv.morphologyEx(source, output, cv.MORPH_CLOSE, morphKernel);\r\n};\r\n\r\n// Calculates intensity thresholds required for canny filter\r\nconst calculateIntensityThresholds = (\r\n  canvas: cv.Mat,\r\n  lowerScalar: number = 0.66,\r\n  upperScalar: number = 1.33,\r\n) => {\r\n  let meanIntensity = cv.mean(canvas)[0];\r\n  let lowerThreshold = lowerScalar * meanIntensity;\r\n  let upperThreshold = upperScalar * meanIntensity;\r\n\r\n  return [lowerThreshold, upperThreshold];\r\n};\r\n\r\nexport const getCornerPoints = (contour: any) => {\r\n  if (!contour) return null;\r\n\r\n  let points: cv.Point[] = [];\r\n    let rect = cv.minAreaRect(contour);\r\n    const center = rect.center\r\n\r\n    let topLeftPoint\r\n    let topLeftDistance = 0\r\n\r\n    let topRightPoint\r\n    let topRightDistance = 0\r\n\r\n    let bottomLeftPoint\r\n    let bottomLeftDistance = 0\r\n\r\n    let bottomRightPoint\r\n    let bottomRightDistance = 0\r\n\r\n    for (let i = 0; i < contour.data32S.length; i += 2) {\r\n        const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\r\n        const distance = Math.hypot(point.x - center.x, point.y - center.y);\r\n        if (point.x < center.x && point.y < center.y) {\r\n        if (distance > topLeftDistance) {\r\n            topLeftPoint = point\r\n            topLeftDistance = distance\r\n        }\r\n        } else if (point.x > center.x && point.y < center.y) {\r\n        if (distance > topRightDistance) {\r\n            topRightPoint = point\r\n            topRightDistance = distance\r\n        }\r\n        } else if (point.x < center.x && point.y > center.y) {\r\n        if (distance > bottomLeftDistance) {\r\n            bottomLeftPoint = point\r\n            bottomLeftDistance = distance\r\n        }\r\n        } else if (point.x > center.x && point.y > center.y) {\r\n        if (distance > bottomRightDistance) {\r\n            bottomRightPoint = point\r\n            bottomRightDistance = distance\r\n        }\r\n        }\r\n    }\r\n\r\n  points.push(new cv.Point(topLeftPoint?.x, topLeftPoint?.y));\r\n  points.push(new cv.Point(topRightPoint?.x, topRightPoint?.y));\r\n  points.push(new cv.Point(bottomRightPoint?.x, bottomRightPoint?.y));\r\n  points.push(new cv.Point(bottomLeftPoint?.x, bottomLeftPoint?.y));\r\n  return points;\r\n};\r\n\r\nconst getGuidancePoints = (config: any, width: number, height: number) => {\r\n  const boxWidth = Math.round(width * (config.documentWidth / 100));\r\n  const boxHeight = Math.round(height * (config.documentHeight / 100));\r\n\r\n  const widthFactor = isMobile ? boxWidth / 2 : boxWidth / 4;\r\n\r\n  const heightFactor = boxHeight / 2;\r\n\r\n  const topLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const topRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 - heightFactor,\r\n  );\r\n  const bottomLeft = new cv.Point(\r\n    width / 2 - widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n  const bottomRight = new cv.Point(\r\n    width / 2 + widthFactor,\r\n    height / 2 + heightFactor,\r\n  );\r\n\r\n  return [topLeft, topRight, bottomRight, bottomLeft];\r\n};\r\n\r\nconst drawGuidanceFrame = (canvas: cv.Mat, points: cv.Point[]) => {\r\n  const white = [255, 255, 255, 255];\r\n  cv.rectangle(canvas, points[0], points[2], white, 2);\r\n};\r\n","import cv from '@techstark/opencv-js';\r\n// Can get number of frames instead\r\nlet timer = 6;\r\n\r\nexport const captureDocument = (\r\n  guidancePoints: cv.Point[],\r\n  lastDetectedPoints: cv.Point[],\r\n  isAreaValid: boolean,\r\n  isPositionValid: boolean,\r\n  updateIsValidArea: (isValid: boolean) => void,\r\n  updateIsValidPosition: (isValid: boolean) => void,\r\n  guideRef: any,\r\n  capturingType: string,\r\n  capturingMargin: number,\r\n) => {\r\n  const guideRefCurrent = guideRef.current;\r\n  if (!lastDetectedPoints) return;\r\n\r\n  const guidancePointsMat = cv.matFromArray(\r\n    guidancePoints.length,\r\n    1,\r\n    cv.CV_32SC2,\r\n    guidancePoints.flatMap((p) => [p.x, p.y]),\r\n  );\r\n\r\n  const detectedPointsMat = cv.matFromArray(\r\n    lastDetectedPoints.length,\r\n    1,\r\n    cv.CV_32SC2,\r\n    lastDetectedPoints.flatMap((p) => [p.x, p.y]),\r\n  );\r\n\r\n  if (capturingType === 'area') {\r\n    const guidanceArea = cv.contourArea(guidancePointsMat);\r\n    const detectedArea = cv.contourArea(detectedPointsMat);\r\n\r\n    updateIsValidArea(\r\n      validateArea(guidanceArea, detectedArea, guideRefCurrent),\r\n    );\r\n    if (!isAreaValid) {\r\n      timer = 6;\r\n      return;\r\n    }\r\n  } else if (capturingType === 'edges') {\r\n    let distances = calculatePointLineDistances(\r\n      lastDetectedPoints,\r\n      guidancePoints,\r\n    );\r\n\r\n    updateIsValidArea(\r\n      validateDistances(\r\n        distances,\r\n        guidancePoints,\r\n        capturingMargin,\r\n        guideRefCurrent,\r\n      ),\r\n    );\r\n    if (!isAreaValid) {\r\n      timer = 6;\r\n      return;\r\n    }\r\n  }\r\n\r\n  updateIsValidPosition(\r\n    validatePosition(guidancePoints, lastDetectedPoints, guideRefCurrent),\r\n  );\r\n  if (!isPositionValid) {\r\n    timer = 6;\r\n    return;\r\n  }\r\n\r\n  if (isAreaValid && isPositionValid) {\r\n    guideRefCurrent.innerText = 'Document ready to be captured.';\r\n    console.log('Document ready to be captured.');\r\n    console.log(timer);\r\n    timer--;\r\n  }\r\n\r\n  if (timer === 0) {\r\n    guideRefCurrent.innerText = 'CAPTURE';\r\n    console.log('CAPTURE');\r\n    timer = 6;\r\n  }\r\n\r\n  guidancePointsMat.delete();\r\n  detectedPointsMat.delete();\r\n};\r\n\r\nconst validateDistances = (\r\n  distances: number[],\r\n  guidancePoints: cv.Point[],\r\n  margin: number,\r\n  guideRefCurrent: any,\r\n) => {\r\n  let width = guidancePoints[1].x - guidancePoints[0].x;\r\n\r\n  if (distances.every((num) => num < 0)) {\r\n    guideRefCurrent.innerText = 'Zoom out.';\r\n    return false;\r\n  }\r\n\r\n  if (distances.every((num) => num >= 0)) {\r\n    if (distances.some((distance) => distance / width > margin / 100)) {\r\n      guideRefCurrent.innerText = 'Zoom in.';\r\n      return false;\r\n    }\r\n    guideRefCurrent.innerText = '';\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst calculatePointLineDistances = (\r\n  lastDetectedPoints: cv.Point[],\r\n  guidancePoints: cv.Point[],\r\n) => {\r\n  let distances = [];\r\n\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[0],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[1],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n\r\n  distances.push(\r\n    -calculatePointLineDistance(\r\n      lastDetectedPoints[2],\r\n      guidancePoints[1],\r\n      guidancePoints[2],\r\n    ),\r\n  );\r\n\r\n  distances.push(\r\n    calculatePointLineDistance(\r\n      lastDetectedPoints[3],\r\n      guidancePoints[0],\r\n      guidancePoints[3],\r\n    ),\r\n  );\r\n\r\n  return distances;\r\n};\r\n\r\nconst calculatePointLineDistance = (\r\n  point: cv.Point,\r\n  lineStart: cv.Point,\r\n  lineEnd: cv.Point,\r\n) => {\r\n  // Absolute value is not calculated on purpose\r\n  let numerator =\r\n    (lineEnd.y - lineStart.y) * point.x -\r\n    (lineEnd.x - lineStart.x) * point.y +\r\n    lineEnd.x * lineStart.y -\r\n    lineEnd.y * lineStart.x;\r\n  let denominator = Math.sqrt(\r\n    (lineEnd.y - lineStart.y) ** 2 + (lineEnd.x - lineStart.x) ** 2,\r\n  );\r\n\r\n  return numerator / denominator;\r\n};\r\n\r\nconst validateArea = (\r\n  guidanceArea: number,\r\n  detectedArea: number,\r\n  guideRefCurrent: any,\r\n) => {\r\n  let minArea = 0.5 * guidanceArea;\r\n\r\n  if (detectedArea < minArea) {\r\n    guideRefCurrent.innerText = 'Zoom in.';\r\n    console.log('Zoom in.');\r\n  }\r\n\r\n  if (detectedArea > guidanceArea) {\r\n    guideRefCurrent.innerText = 'Zoom out';\r\n    console.log('Zoom out');\r\n  }\r\n\r\n  if (minArea <= detectedArea && detectedArea <= guidanceArea) {\r\n    guideRefCurrent.innerText = 'Area in range.';\r\n    console.log('Area in range.');\r\n\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nconst validatePosition = (\r\n  guidancePoints: cv.Point[],\r\n  detectedPoints: cv.Point[],\r\n  guideRefCurrent: any,\r\n) => {\r\n  const guidanceBounds = getBounds(guidancePoints);\r\n  const detectedBounds = getBounds(detectedPoints);\r\n\r\n  if (detectedBounds.minX < guidanceBounds.minX) {\r\n    guideRefCurrent.innerText = 'Move left';\r\n    console.log('Move left');\r\n    return false;\r\n  }\r\n\r\n  if (detectedBounds.maxX > guidanceBounds.maxX) {\r\n    guideRefCurrent.innerText = 'Move right';\r\n    console.log('Move right');\r\n    return false;\r\n  }\r\n\r\n  // Check up-down\r\n  if (detectedBounds.minY < guidanceBounds.minY) {\r\n    guideRefCurrent.innerText = 'Move up';\r\n    console.log('Move up');\r\n    return false;\r\n  }\r\n\r\n  if (detectedBounds.maxY > guidanceBounds.maxY) {\r\n    guideRefCurrent.innerText = 'Move down';\r\n    console.log('Move down');\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst getBounds = (points: cv.Point[]) => {\r\n  const minX = Math.min(...points.map((point) => point.x));\r\n  const maxX = Math.max(...points.map((point) => point.x));\r\n  const minY = Math.min(...points.map((point) => point.y));\r\n  const maxY = Math.max(...points.map((point) => point.y));\r\n\r\n  return { minX, maxX, minY, maxY };\r\n};\r\n","import React, { useRef } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { useGlobalContext } from '../GlobalContext';\r\nimport { animationManager } from './AnimationManger';\r\nimport {\r\n  detectDocument,\r\n  getVideoConstraints,\r\n  renderVideoToCanvas,\r\n  setupCanvasSize,\r\n} from './CameraUtils';\r\nimport { captureDocument } from './CaptureDocument';\r\n\r\nconst Camera = (config: any) => {\r\n  const [globalData, setGlobalData] = useGlobalContext();\r\n\r\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const canvasWrapperRef = React.useRef<HTMLDivElement | null>(null);\r\n  const videoRef = React.useRef<Webcam>(null);\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const guideRef = React.useRef<HTMLDivElement | null>(null);\r\n  const screenReaderRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n  const videoConstraints = getVideoConstraints();\r\n\r\n  const initialiseCanvas = () => {\r\n    setupCanvasSize(\r\n      videoRef,\r\n      canvasRef,\r\n      canvasWrapperRef,\r\n      config,\r\n      updateGuidancePoints,\r\n    );\r\n  };\r\n\r\n  const renderVideo = () => {\r\n    renderVideoToCanvas(\r\n      videoRef,\r\n      canvasRef,\r\n      config,\r\n      globalData.autoCapture.guidancePoints,\r\n      globalData.autoCapture.lastDetectedPoints,\r\n    );\r\n  };\r\n\r\n  const runDetection = () => {\r\n    detectDocument(videoRef, canvasRef, config, updatePointDetected);\r\n  };\r\n\r\n  const runCapturing = () => {\r\n    captureDocument(\r\n      globalData.autoCapture.guidancePoints,\r\n      globalData.autoCapture.lastDetectedPoints,\r\n      globalData.autoCapture.isAreaValid,\r\n      globalData.autoCapture.isPositionValid,\r\n      updateIsValidArea,\r\n      updateIsValidPosition,\r\n      guideRef,\r\n      config.capturingType,\r\n      config.capturingMargin,\r\n    );\r\n  };\r\n\r\n  const updatePointDetected = (points: any) => {\r\n    const globalDataUpdate = globalData;\r\n    globalDataUpdate.autoCapture.lastDetectedPoints = points;\r\n    setGlobalData(globalDataUpdate);\r\n  };\r\n\r\n  const updateGuidancePoints = (points: any) => {\r\n    const globalDataUpdate = globalData;\r\n    globalDataUpdate.autoCapture.guidancePoints = points;\r\n    setGlobalData(globalDataUpdate);\r\n  };\r\n\r\n  const updateIsValidArea = (isValid: boolean) => {\r\n    const globalDataUpdate = globalData;\r\n    globalDataUpdate.autoCapture.isAreaValid = isValid;\r\n    setGlobalData(globalDataUpdate);\r\n  };\r\n\r\n  const updateIsValidPosition = (isValid: boolean) => {\r\n    const globalDataUpdate = globalData;\r\n    globalDataUpdate.autoCapture.isPositionValid = isValid;\r\n    setGlobalData(globalDataUpdate);\r\n  };\r\n\r\n  const runScreenReader = () => {\r\n    const guideText = guideRef.current?.innerText;\r\n    const screenReaderText = screenReaderRef.current?.innerText;\r\n\r\n    if (screenReaderText !== guideText && screenReaderRef.current && guideRef.current) {\r\n      screenReaderRef.current && guideText ? screenReaderRef.current.innerText = guideText : screenReaderRef.current.innerText = '';\r\n    }\r\n  }\r\n\r\n  const videoStarted = () => {\r\n    // seems to have issues on ios without delay\r\n    setTimeout(() => {\r\n      initialiseCanvas();\r\n      animationManager.registerTask(renderVideo, 60);\r\n      animationManager.registerTask(runDetection, 10);\r\n      animationManager.registerTask(runCapturing, 2);\r\n      animationManager.registerTask(runScreenReader, 10);\r\n    }, 2000);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <div style={{position: 'relative'}}>\r\n        <div ref={videoWrapperRef}><Webcam videoConstraints={videoConstraints} ref={videoRef} onUserMedia={videoStarted} style={{position: 'absolute'}} /></div>\r\n        <div ref={canvasWrapperRef} style={{position: 'relative'}}>\r\n          <canvas id=\"canvasOutput\" ref={canvasRef} style={{position: 'absolute'}}></canvas>\r\n          <div ref={guideRef} id=\"guidance\" style={{position: 'absolute', color: \"white\", textAlign: \"center\", bottom: \"40px\", width: \"100%\"}}>Position document inside boundary</div>\r\n          <div ref={screenReaderRef} role=\"alert\" style={{clipPath: 'inset(50%)', height: '1px', overflow: 'hidden', position: 'absolute', whiteSpace: 'nowrap', width: '1px'}}>Position document inside boundary</div>\r\n        </div>\r\n      </div>\r\n      <div style={{position: 'relative'}}><a href=\"/camster\">Back to settings</a></div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Camera;"],"names":["UniqueNameSet","Set","constructor","values","super","names","value","this","includes","name","delete","push","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","forEach","task","requestAnimationFrame","registerTask","add","toString","size","unregisterTask","cancelAnimationFrame","drawDebugContour","input","points","contour","cv","pointArray","length","flatMap","p","x","y","push_back","color","isQuadrilateral","rows","findBiggestContour","contoursVec","minAreaThreshold","maxArea","largestContour","i","get","area","peri","approx","preprocessImage","source","output","arguments","undefined","kernelSize","Math","max","floor","min","cols","intensityThresholds","calculateIntensityThresholds","morphKernel","canvas","lowerScalar","upperScalar","meanIntensity","getCornerPoints","_topLeftPoint","_topLeftPoint2","_topRightPoint","_topRightPoint2","_bottomRightPoint","_bottomRightPoint2","_bottomLeftPoint","_bottomLeftPoint2","center","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","data32S","point","distance","hypot","getGuidancePoints","config","width","height","boxWidth","round","documentWidth","boxHeight","documentHeight","widthFactor","isMobile","heightFactor","topLeft","topRight","bottomLeft","drawGuidanceFrame","timer","validateDistances","distances","guidancePoints","margin","guideRefCurrent","every","num","innerText","some","calculatePointLineDistances","lastDetectedPoints","calculatePointLineDistance","lineStart","lineEnd","sqrt","validateArea","guidanceArea","detectedArea","minArea","console","log","validatePosition","detectedPoints","guidanceBounds","getBounds","detectedBounds","minX","maxX","minY","maxY","map","globalData","setGlobalData","useGlobalContext","videoWrapperRef","React","canvasWrapperRef","videoRef","canvasRef","useRef","guideRef","screenReaderRef","videoConstraints","getVideoConstraints","facingMode","exact","ideal","window","innerHeight","screen","initialiseCanvas","setupCanvasSize","updateGuidancePoints","_videoRef$current","video","current","videoWidth","videoHeight","canvasWrapper","style","renderVideo","renderVideoToCanvas","_videoRef$current2","canv","getCanvas","getContext","willReadFrequently","drawImage","img","debug","autoCapture","runDetection","detectDocument","updatePointDetected","_videoRef$current3","cap","src","read","hierarchy","runCapturing","captureDocument","isAreaValid","isPositionValid","updateIsValidArea","updateIsValidPosition","capturingType","capturingMargin","guidancePointsMat","detectedPointsMat","globalDataUpdate","isValid","runScreenReader","_guideRef$current","_screenReaderRef$curr","guideText","_jsxs","children","position","_jsx","ref","Webcam","onUserMedia","videoStarted","setTimeout","id","textAlign","bottom","role","clipPath","overflow","whiteSpace","href"],"sourceRoot":""}